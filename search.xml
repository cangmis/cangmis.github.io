<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F24%2Fjava%E5%8F%8C%E6%8C%87%E9%92%88--%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 题目要点 在原地删除重复出现的元素 不要使用额外的数组空间 只能使用 O(1) 额外空间 思路 不能开辟数组，只能在该数组操作，就想到了双指针的方法。i指针和j指针。j在前面，也就是慢指针，i在j的后面是快指针。 快指针初始化时候指向数组的第二项。 如果nums[i]!=nums[i-1]，就要跳过重复项，i和j同时加一。 如果nums[i]=nums[i-1]的话就移动i，令i+1， 找到nums[i]!=nums[i-1]的i下标对应的数组值。将该值赋值到j下标的数组元素身上依次覆盖。最后数组的前几位一定是有序的无重复数。 记得判断数组是否为空。 代码class Solution { public int removeDuplicates(int[] nums) { if(nums.length==0) return 0; int j=1; for(int i=1;i&lt;nums.length;) { if(nums[i]==nums[i-1]) { i++; } else if(nums[i]!=nums[i-1]) { nums[j]=nums[i]; j++; i++; } } return j; } }执行用时 : 1 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗 :39.8 MB, 在所有 Java 提交中击败了95.22%的用户]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图书馆管理项目（Ajax,jQuery，JSON,JSTL,正则表达式，过滤器等的应用）]]></title>
    <url>%2F2019%2F09%2F23%2F%E5%9B%BE%E4%B9%A6%E9%A6%86%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[项目需求 主要功能： 1、注册登录功能 注册：信息包括用户名、密码、密码确认、手机号码和邮箱，要使用正则表达式进行校验 登录：注册成功直接跳转到登录页面，登录成功后显示用户名 登录成功后进入管理页面。 使用过滤器限制不登录不能进入管理页面 2、图书分类管理 分类添加：分类id、名字、描述 3、图书管理 图书添加：内容包括图书id、图书名、图书分类、价格、描述 图书查询：列出所有图书完整信息，可以按id、图书名、分类进行查询，使用Ajax局部刷新，显示所有图书时要使用jstl 实现过程:注册功能的实现：注册包括用户名，密码，密码确认，手机号码和邮箱并且都要进行正则表达式进行校验 所以我们要用js写一个事件。比如说用户名，当失去鼠标焦点的时候就触发一个事件。该事件要做的就是要判断该用户名是否满足需求 定义一个正则表达式。用正则表达式的text方法来检验name的值是否正确。不正确的话就清除该文本框的内容并让用户重新输入。 密码确认的时时候要比较两次密码输入是否一致，不一致也要清除文本框，让用户重新输入。 我们在点击提交的时候，要将页面跳转到一个RegistServlet里面，目的是进行用户信息的保存。以便于用户登陆时信息的比对。 因为有多个用户。所以我们在进行信息保存的时候通常保存在一个列表里面，列表的中保存的类型是用户类。 那么我们要先创建一个用户类：属性是用户的名字，密码，手机，和邮箱号。还有getter，setter方法。构造函数方法。 接着我们在一个操作类中保存这个用户。定义一个操作类为LibDaoImpl，在这里定义一个 private static final Listuserlist=new ArrayList();用来保存用户列表。还有一个方法是addUserList(User user)//用来添加用户。 我们在servlet中用request.getParameter(“”)方法提取出用户的属性值。利用用户类的构造函数方法对User类进行初始化。调用LibDaoImpl中的addUserList（User user）方法将该注册用户添加到列表里。 登陆功能的实现登陆的时候，我们有两点需要注意：第一点，我们先判断该用户是否注册过，第二点，我们判断该用户的用户名和用户密码是否输入正确 我们判断的唯一依据就是根据注册时，我们保存的用户列表。因为用户列表是private 我们要通过公有的方法去访问到该列表。 我们首先看该列表有没有登陆时候输入的用户名。那么我们在LibDaoImpl中创建的方法就应该是public boolean isexits(String username） 我们在LoginServlet页面利用request.getParemeter(“”)方法获取用户的用户名。 然后调用isexits方法如果返回值为false。让它跳转到注册页面。如果是ture就要进行下一步的用户名和密码是否正确的验证环节。 同样在LoginServlet中创建一个方法islogin(Stringusername,String password)。 如果返回值为true 就跳转到图书管理页面，如果为false就重新登陆。 我们为了防止用户跳过登陆和注册就直接进入图书管理页面。我们要弄一个过滤器。过滤掉没有登陆的页面。 图书分类添加的实现分类时 有分类id，分类名，分类表述。因为有多个分类，所以我们也利用一个保存分类的列表来存储。存储的数据类型时一个Map用来保存属性和值的信息。在操作类中定义：private static final List&lt;Map&lt;String, Object&gt;&gt; categorys=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();对应的方法是public void addBookCatgory(String id, String catgoryName, String description)与上述过程一样，创建一个servlet CatgoryServlet。获取图书的分类id，分类名，和分类描述，利用方法addBookCatgory()方法来保存图书分类信息。外界过去图书分类用到的方法是public List&lt;Map&lt;String, Object&gt;&gt; getAllBookCatgory()； 如果在图书添加页面分类下拉框中显示分类信息。这时要用到JSTL在addBook.jsp中利用获取图书分类的方法 获取categoryList列表，利用JSTL中的迭代功能进行遍历显示 图书添加的实现 图书添加时候，我们要保存图书信息，建立一个图书类。属性值为bookId，bookName，catgoryName，count，description; 添加getter和setter方法和构造函数的方法。好多图书，用列表来保存。在操作类中定义一个 private static final List addBooklist =new ArrayList&lt;&gt;();对应方法是 addBook(Book book)； 获取图书信息对应的方法是public List getBook(); 在AddBookServlet中利用getparameter方法获取图书信息。利用操作类中添加图书的方法将图书信息存储到图书列表中。 在显示图书页面中利用getBook()方法获取图书信息。 图书查询的实现。我们可以根据图书的id 图书的分类 和图书的名称任意几个属性来获取我们所需要的图书。 那么我们就要在操作类中定义一个方法：该方法就是根据条件来找到对应的图书信息，返回是一个列表。 public List getBookByCondition(String bookId,String bookName,String catoryName) 这个操作的利用了Ajax 的动态刷新。 创建一个Servlet。 SelectBookServlet中我们获取索要查询的图书的分类，id和图书的名称利用 getBookByCondition的方法来获取图书列表，再用JSSON.toJSONString()方法将列表序列化返回到 查询的界面。完成查询，利用ajax 完成动态刷新。 代码静态网页代码 1.初始界面index.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;%String flag=request.getParameter(&quot;flag&quot;); %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type=text/javascript&gt; var flag=&lt;%=flag%&gt; if(flag==1) alert(&quot;该用户用户名或者密码错误&quot;); else if(flag==2) alert(&quot;请先登陆&quot;); else if(flag==3) alert(&quot;已经注册过可直接登陆&quot;); &lt;/script&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书后台管理登录界面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;登录 | &lt;a href=&quot;./regist.jsp&quot;&gt;注册&lt;/a&gt;&lt;/h1&gt; &lt;form action=&quot;./LoginServlet&quot; method=&quot;post&quot;&gt; &lt;table width=&quot;350px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名为3-12位字母数字或下划线组合&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密&amp;nbsp;码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;长度为6-12位的纯数字&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;取消&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;2.注册页面regix &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@page import=&quot;bookclass.LibDaoImpl&quot;%&gt; &lt;%String flag=request.getParameter(&quot;flag&quot;); %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type=text/javascript&gt; var flag=&lt;%=flag%&gt; if(flag==1) alert(&quot;该用户没注册，请注册&quot;); if(flag==2) alert(&quot;该用户已经注册过&quot;); &lt;/script&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;注册界面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;用户注册&lt;/h1&gt; &lt;form action=&quot;./RegistServlet&quot; method=&quot;post&quot;&gt; &lt;table width=&quot;400px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;placeholder=&quot;用户名为3-12位字母数字或下划线组合&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密&amp;nbsp;码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;密码长度为6-12位的纯数字&quot; id=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;checkPWD&quot; id=&quot;checkPWD&quot; placeholder=&quot;密码长度为6-12位的纯数字&quot; &quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;phone&quot; id=&quot;phone&quot; placeholder=&quot;请输入正确的手机号码格式&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入正确邮箱格式&quot; required=&quot;required&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/center&gt; &lt;script type=&quot;text/javascript&quot; &gt; document.getElementById(&quot;password&quot;).onchange=function() { var regex=/^\d{6,12}$/; var password=document.getElementById(&quot;password&quot;).value; if(!(regex.test(password))) { document.getElementById(&quot;password&quot;).value=&quot;&quot;; alert(&quot;密码输入不符合规范，请重新输入&quot;); } } document.getElementById(&quot;username&quot;).onchange=function() { var regex=/^[a-zA-Z0-9_]{3,12}$/; var username=document.getElementById(&quot;username&quot;).value; if(!(regex.test(username))) { document.getElementById(&quot;username&quot;).value=&quot;&quot;; alert(&quot;用户名输入不符合规范，请重新输入&quot;); } } document.getElementById(&quot;checkPWD&quot;).onchange=function() { var password1=document.getElementById(&quot;password&quot;).value; var password2=document.getElementById(&quot;checkPWD&quot;).value; if(!(password1==password2)) { document.getElementById(&quot;password&quot;).value=&quot;&quot;; document.getElementById(&quot;checkPWD&quot;).value=&quot;&quot;; alert(&quot;两次输入密码不一致请重新输入&quot;); } } document.getElementById(&quot;phone&quot;).onchange=function() { var phone=document.getElementById(&quot;phone&quot;).value; var regex=/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$/; if(!(regex.test(phone))) { document.getElementById(&quot;phone&quot;).value=&quot;&quot;; alert(&quot;手机号输入格式错误&quot;); } } document.getElementById(&quot;email&quot;).onchange=function() { var email=document.getElementById(&quot;email&quot;).value; var regex=/^([0-9A-Za-z\-_\.]+)@([0-9a-z]+\.[a-z]{2,3}(\.[a-z]{2})?)$/ if(!(regex.test(email))) { document.getElementById(&quot;email&quot;).value=&quot;&quot;; alert(&quot;邮箱格式错误&quot;); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;3.图书管理页面 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书后台管理系统&lt;/title&gt; &lt;/head&gt; &lt;frameset rows=&quot;20%,*&quot;&gt; &lt;frame src=&quot;./top.jsp&quot;&gt;&lt;/frame&gt; &lt;frameset cols=&quot;10%,*&quot;&gt; &lt;frame src=&quot;./left.html&quot;&gt;&lt;/frame&gt; &lt;frame name=&quot;main&quot;&gt;&lt;/frame&gt; &lt;/frameset&gt; &lt;/frameset&gt; &lt;/html&gt;4.左边的功能框界面left.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书后台管理&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;a href=&quot;./catgory.jsp&quot; target=&quot;main&quot;&gt;分类添加&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;./addBook.jsp&quot; target=&quot;main&quot;&gt;图书添加&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;./showBooks.jsp&quot; target=&quot;main&quot;&gt;图书查询&lt;/a&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;5.上边展示页面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% String name=(String)session.getAttribute(&quot;username&quot;);%&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt; 图书后台管理系统&lt;span style=&quot;font-size:12px&quot;&gt;您好，&lt;%=name %&gt;&lt;/span&gt; &lt;/h1&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;6.添加图书类界面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书分类添加&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;图书分类添加&lt;/h1&gt; &lt;form action=&quot;./CatgoryServlet&quot; method=&quot;post&quot;&gt; &lt;table width=&quot;400px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;分类ID&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;名&amp;nbsp;字&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;catgoryName&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;描&amp;nbsp;述&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;description&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;7.添加图书界面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;%@ page import=&quot;bookclass.LibDaoImpl&quot; %&gt; &lt;%@ page import=&quot;java.util.*&quot; %&gt; &lt;%@page import=&quot;java.util.Map&quot;%&gt; &lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;%LibDaoImpl dao=new LibDaoImpl(); List&lt;Map&lt;String,Object&gt;&gt; list=new ArrayList(); list=dao.getcatgorylist(); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书添加&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;图书添加&lt;/h1&gt; &lt;form action=&quot;./AddBookServlet&quot; method=&quot;post&quot;&gt; &lt;table width=&quot;400px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;图书ID&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot; placeholder=&quot;请输入数字&quot; pattern=&quot;\d+&quot; required=&quot;required&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;图书名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;图书分类&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;catgoryName&quot;&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;c&quot;&gt; &lt;option value=&quot;${c.catgoryName}&quot;&gt;&amp;nbsp;&amp;nbsp;${c.catgoryName}&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; placeholder=&quot;请输入价格&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;描述&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;description&quot; placeholder=&quot;请输入描述信息&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;8.书籍展示页面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@page import=&quot;bookclass.LibDaoImpl&quot;%&gt; &lt;%@page import=&quot;bookclass.Book&quot;%&gt; &lt;%@page import=&quot; java.util.List&quot;%&gt; &lt;%@page import=&quot; java.util.ArrayList&quot;%&gt; &lt;%@page import=&quot;java.util.Map&quot;%&gt; &lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;% LibDaoImpl dao=new LibDaoImpl(); List&lt;Book&gt;list =dao.getBook(); request.setAttribute(&quot;booklist&quot;,list); %&gt; &lt;/script&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书查询&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;图书查询&lt;/h1&gt; &lt;p&gt; 图书ID：&lt;input type=&quot;text&quot; name=&quot;bookID&quot; id=&quot;bookId&quot;&gt; 图书名：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; id=&quot;bookName&quot;&gt; 分类：&lt;input type=&quot;text&quot; name=&quot;catgoryName&quot; id=&quot;catoryName&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;查询&quot; id=&quot;search&quot;&gt; &lt;/p&gt; &lt;hr&gt; &lt;table width=&quot;800px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;分类&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;cont&quot;&gt; &lt;c:forEach items=&quot;${booklist}&quot; var=&quot;b&quot;&gt; &lt;tr&gt; &lt;td&gt;${b.getBookId()}&lt;/td&gt; &lt;td&gt;${b.getBookName()}&lt;/td&gt; &lt;td&gt;${b.getBookCatogry()}&lt;/td&gt; &lt;td&gt;${b.getBookPrice() }&lt;/td&gt; &lt;td&gt;${b.getBookDescription() }&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/center&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#search&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/book/SelectBookServlet&quot;, &quot;data&quot;:{bookID:$(&quot;#bookId&quot;).val(), bookName:$(&quot;#bookName&quot;).val(), catgoryName:$(&quot;#catoryName&quot;).val() }, &quot;type&quot;:&quot;post&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json){ var content=&quot;&quot;; for(var i=0;i&lt;json.length;i++){ content=content+&quot;&lt;tr&gt;&lt;td&gt;&quot;+json[i].bookId + &quot;&lt;/td&gt;&lt;td&gt;&quot;+json[i].bookName+ &quot;&lt;/td&gt;&lt;td&gt;&quot;+json[i].bookCatogry+ &quot;&lt;/td&gt;&lt;td&gt;&quot;+json[i].bookPrice+ &quot;&lt;/td&gt;&lt;td&gt;&quot;+json[i].bookDescription+ &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; $(&quot;#cont&gt;tr&quot;).remove(); } $(&quot;#cont&quot;).html(content); } }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;Book类 package bookclass; public class Book { private String bookId; private String bookName; private String bookCatogry; private String bookPrice; private String bookDescription; @Override public String toString() { return &quot;Book [bookId=&quot; + bookId + &quot;, bookName=&quot; + bookName + &quot;, bookCatogry=&quot; + bookCatogry + &quot;, bookPrice=&quot; + bookPrice + &quot;, bookDescription=&quot; + bookDescription + &quot;]&quot;; } public Book() { // TODO Auto-generated constructor stub } public String getBookId() { return bookId; } public void setBookId(String bookId) { this.bookId = bookId; } public String getBookName() { return bookName; } public void setBookName(String bookName) { this.bookName = bookName; } public String getBookCatogry() { return bookCatogry; } public void setBookCatogry(String bookCatogry) { this.bookCatogry = bookCatogry; } public String getBookPrice() { return bookPrice; } public void setBookPrice(String bookPrice) { this.bookPrice = bookPrice; } public String getBookDescription() { return bookDescription; } public void setBookDescription(String bookDescription) { this.bookDescription = bookDescription; } }User类 package bookclass; public class User { public User(String username, String password, String phone, String email) { super(); this.username = username; this.password = password; this.phone = phone; this.email = email; } private String username; private String password; private String phone; private String email; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } }操作类 package bookclass; import java.util.ArrayList; import java.util.List; import java.util.Map; public class LibDaoImpl { private static final List&lt;User&gt; userlist=new ArrayList&lt;&gt;(); private static final List&lt;Map &lt;String,Object&gt; &gt; catgorylist =new ArrayList&lt;&gt;(); private static final List&lt;Book&gt; booklist=new ArrayList&lt;&gt;(); public void addUser(User user)//添加用户 { userlist.add(user); } public boolean isExitsUsername(String username)//判断该用户是否注册过 { for(User user:userlist) { if(user.getUsername().equals(username)) { return true; } } return false; } public boolean successLogin(String username,String password) { for(User user:userlist) { if(user.getUsername().equals(username)&amp;&amp;user.getPassword().equals(password)) { return true; } } return false; } public void addcatgorylist(Map &lt;String,Object&gt; map)//添加图书分类 { catgorylist.add(map); } public List&lt;Map &lt;String,Object&gt; &gt; getcatgorylist()//获取图书分类 { return catgorylist; } public void addBook(Book book) { booklist.add(book); } public List&lt;Book&gt; getBook() { return booklist; } public List&lt;Book&gt; findBookByCondition(String bookID,String bookCatgory,String bookName) { List&lt;Book&gt; rightbook=new ArrayList&lt;&gt;(); for(Book book:booklist) { if(book.getBookCatogry().equals(bookCatgory)||book.getBookName().equals(bookName)||book.getBookId().equals(bookID)) { rightbook.add(book); } } return rightbook; } }添加书的servlet package servlet; import bookclass.Book; import bookclass.LibDaoImpl; import java.io.IOException; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Servlet implementation class AddBookServlet */ @WebServlet(&quot;/AddBookServlet&quot;) public class AddBookServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public AddBookServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); String id=request.getParameter(&quot;id&quot;); String bookName=request.getParameter(&quot;bookName&quot;); String catgoryName=request.getParameter(&quot;catgoryName&quot;); String price=request.getParameter(&quot;price&quot;); String description=request.getParameter(&quot;description&quot;); Book book=new Book(); book.setBookCatogry( catgoryName); book.setBookDescription(description); book.setBookId(id); book.setBookName(bookName); book.setBookPrice(price); LibDaoImpl dao=new LibDaoImpl(); dao.addBook(book); response.sendRedirect(&quot;./showBooks.jsp&quot;); } }添加书类的servlet package servlet; import java.io.IOException; import java.util.HashMap; import java.util.Map; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import bookclass.LibDaoImpl; /** * Servlet implementation class CatgoryServlet */ @WebServlet(&quot;/CatgoryServlet&quot;) public class CatgoryServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CatgoryServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); String id=request.getParameter(&quot;id&quot;); String catgoryName =request.getParameter(&quot;catgoryName&quot;); String description =request.getParameter(&quot;description&quot;); LibDaoImpl dao=new LibDaoImpl(); Map&lt;String,Object&gt;map=new HashMap&lt;&gt;(); map.put(&quot;id&quot;, id); map.put(&quot;catgoryName&quot;,catgoryName); map.put(&quot;description&quot;,description); dao.addcatgorylist(map); response.sendRedirect(&quot;./catgory.jsp&quot;); } }用户登陆servlet package servlet; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import bookclass.LibDaoImpl; /** * Servlet implementation class LoginServlet */ @WebServlet(&quot;/LoginServlet&quot;) public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public LoginServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub String username=request.getParameter(&quot;username&quot;); String password=request.getParameter(&quot;password&quot;); LibDaoImpl dao=new LibDaoImpl(); if(dao.isExitsUsername(username)) { if(dao.successLogin(username, password)) { request.getSession().setAttribute(&quot;username&quot;,username); response.sendRedirect(&quot;./server.html&quot;); } else { response.sendRedirect(&quot;./index.jsp?flag=1&quot;); } } else response.sendRedirect(&quot;./regist.jsp?flag=2&quot;); } }用户注册servlet package servlet; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import bookclass.LibDaoImpl; import bookclass.User; /** * Servlet implementation class RegistServlet */ @WebServlet(&quot;/RegistServlet&quot;) public class RegistServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public RegistServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub request.setCharacterEncoding(&quot;UTF-8&quot;); String username=request.getParameter(&quot;username&quot;); String password=request.getParameter(&quot;password&quot;); String phone=request.getParameter(&quot;phone&quot;); String email=request.getParameter(&quot;email&quot;); LibDaoImpl dao =new LibDaoImpl(); if(dao.isExitsUsername(username))//为真表明已经注册过 { response.sendRedirect(&quot;./index.jsp?flag=3&quot;); } else { User user=new User(username,password,phone,email); dao.addUser(user); response.sendRedirect(&quot;./index.jsp&quot;); } } }查询书籍servlet package servlet; import java.io.IOException; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; import bookclass.Book; import bookclass.LibDaoImpl; /** * Servlet implementation class SelectBookServlet */ @WebServlet(&quot;/SelectBookServlet&quot;) public class SelectBookServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public SelectBookServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub response.setContentType(&quot;text/html;charset=utf-8&quot;); String bookID=request.getParameter(&quot;bookID&quot;); String bookName=request.getParameter(&quot;bookName&quot;); String catgoryName=request.getParameter(&quot;catgoryName&quot;); LibDaoImpl dao=new LibDaoImpl(); List&lt;Book&gt; abook=dao.findBookByCondition(bookID, catgoryName, bookName); String json=JSON.toJSONString(abook); response.getWriter().println(json); } }两个过滤类1.解决中文乱码的过滤类 package filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; /** * Servlet Filter implementation class CharacterEncodingFilter */ @WebFilter(&quot;/CharacterEncodingFilter&quot;) public class CharacterEncodingFilter implements Filter { private FilterConfig config; /** * Default constructor. */ public CharacterEncodingFilter() { // TODO Auto-generated constructor stub } /** * @see Filter#destroy() */ public void destroy() { // TODO Auto-generated method stub } /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(config.getInitParameter(&quot;charset&quot;)); chain.doFilter(request, response); } public void init(FilterConfig config) throws ServletException { this.config = config; } public FilterConfig getConfig() { return config; } public void setConfig(FilterConfig config) { this.config = config; } }2.解决用户没登陆就进入界面的过滤类 package filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Servlet Filter implementation class LoginFilter */ @WebFilter(&quot;/LoginFilter&quot;) public class LoginFilter implements Filter { /** * Default constructor. */ public LoginFilter() { // TODO Auto-generated constructor stub } /** * @see Filter#destroy() */ public void destroy() { // TODO Auto-generated method stub } /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest hrequest=(HttpServletRequest)request; HttpServletResponse hresponse=(HttpServletResponse)response; String name=(String)hrequest.getSession().getAttribute(&quot;username&quot;); System.out.println(name); if(name==null||name.length()==0) { hresponse.sendRedirect(hrequest.getContextPath()+&quot;/index.jsp?flag=2&quot;); return ; } else { chain.doFilter(request, response); return; } } /** * @see Filter#init(FilterConfig) */ public void init(FilterConfig fConfig) throws ServletException { // TODO Auto-generated method stub } }3.xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;book&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;loginFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.LoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;loginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/server.html&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;charset&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>图书馆管理项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F19%2F%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123输出: 321示例 2: 输入: -123输出: -321示例 3: 输入: 120输出: 21注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 思路： 这道题翻转比较简单，利用x%10求剩余整数的最后一位。通过循环实现将最后一位*10变成第一位。倒数第二位变成第二位等等依次翻转。每次x=x/10； 这道题关键在于处理溢出。由计算我们可知：2^31-1=2147483647,-2^31=-2147483648 所以当我们反转的时候一定要注意得数在这两个范围内。那么我们怎么判断翻转之后在这个范围内。我们通过观察发现两个数只有最后一位不同。我们可以提取要翻转的数的第一位出来，把除了第一位剩下位翻转结果求出来，如果是正数。那么他应该小于(2^31-1)/10; 如果是负数那么它应该大于(2^31)/10，如果相等的话。比较第一位也就是翻转后的最后一位。正数的话一定小于7，负数的话大于-8； 否则返回零。 代码class Solution { public int reverse(int x) { int res=0; int r; while(x!=0) { r=x%10; x=x/10; if(res&gt;Integer.MAX_VALUE/10||res==Integer.MAX_VALUE/10&amp;&amp;r&gt;7)return 0; if(res&lt;Integer.MIN_VALUE/10||res==Integer.MIN_VALUE/10&amp;&amp;r&lt;-8)return 0; res=res*10+r; } return res; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F19%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[无重复字符的最长字串 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。思路1：刚开始想的是动态规划，先定义一个数组dp[i]用来记录以字符串中每个字符为结尾的无重复字符的最大长度。每次求解过程中取最优。 在求以每个字符为结尾的无重复字符的最大长度时，判断已经比较过的字符串中有没有当前的字符，如果存在： 就求该字符和与它相同的字符最后一次出现的位置的差值d如果d&lt;=d[i-1]那么就说明和它相同的字符出现在上一个字符为结尾的最长无重复子串中，那么d[i]=d;也就是将和它重复的那个字符以及它之前的所有字符全都舍去。从下一个和它不同的字符开始计算最长字串长度 但是如果d&gt;d[i-1]证明它不在上一个字符的最长字串中,它的存在给它上一个字符的dp[i-1]都无影响，对该字符更没有影响，直接在上一个字符的dp[i-1]+1即可，d[i]=d[i-1]+1; 如果不存在就直接d[i]=d[i]+1 代码如下class Solution { public int lengthOfLongestSubstring(String s) { int[] dp=new int[s.length()]; int res=1; if(s.length()==0) return 0; dp[0]=1; for(int i=1;i&lt;s.length();i++) { char c=s.charAt(i);//获取此时的字符 if(s.contains(c+&quot;&quot;)) { int index=s.lastIndexOf(c,i-1);//找到该字符在i-1个字符之前最后一次出现的位置 int d=i-index; if(d&lt;=dp[i-1]) { dp[i]=d; } else if(d&gt;dp[i-1]) { dp[i]=dp[i-1]+1; } } else { dp[i]=dp[i-1]+1; } res=Math.max(res,dp[i]);//每次更新res的值。 } return res; } }思路2：还有一种是滑动窗口的办法，这个是处理字符串很有效的很常见的办法。 具体思路：我们设置一个窗口不断更新他的左右边界索引，确保此时窗口里面的长度是以该字符结尾的最长字串长度。每次更新窗口的时候，也要更新记录最长字串长度的变量值。 首先我们可以用set来构造这样的一个窗口。遍历整个字符串。每次遇到一个新字符的时候，看看窗口中有没有该字符，如果没有直接加入这个窗口。然后更新右边界的索引值。如果在窗口中有该值，那为了让新值进入这个窗口，只能留下相同值后面的值了，这样保证不重复。这个思路比上一个思路优化在，我们只需要判断窗口有没有该字符就行。而不用判断之前的整个子串有没有该字符。 代码： class Solution { public int lengthOfLongestSubstring(String s) { Set&lt;Character&gt;set=new HashSet&lt;&gt;(); int j=0; int i=0; int len=s.length(); char[] ss=s.toCharArray(); int res=0; while(i&lt;len&amp;&amp;j&lt;len) { if((!set.contains(ss[j]))) { set.add(ss[j++]); res=Math.max(res,j-i); } else { set.remove(ss[i++]); } } return res; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听器项目（用户登录控制）]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%9B%91%E5%90%AC%E5%99%A8%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[要求: 通过过滤器实现登陆控制，未登陆用户不能访问系统首页 用户登陆，将登录名存储到session中 登陆监听器监听session属性中登陆值属性变化 若登陆用户用户名已登陆到系统，清除前次登陆信息 首先写登陆页面index.jsp，构造登陆页面的表单，用户输入用户名和密码等 &lt;form action=&quot;login.jsp&quot; method=&quot;post&quot;&gt; &lt;h1&gt;系统登录&lt;/h1&gt; &lt;label&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/label&gt; &lt;label&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/label&gt; &lt;span&gt;&amp;nbsp;&lt;/span&gt; &lt;label&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;登录&quot;/&gt; &lt;/label&gt; &lt;/form&gt;在xml中将index.jsp设成默认首页、 &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;因为表单提交到login.jsp中 所以我们要对login.jsp进行代码书写我们为了实现登陆控制：没有登陆的用户不可以进入主页。我们要在login.jsp中实现将用户的姓名和密码放到session中。以便在后续过滤器的过滤。 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); session.setAttribute(&quot;loginUser&quot;, username);//登录完成，将登录用户名存储至session对象 response.sendRedirect(request.getContextPath()+&quot;/main.jsp&quot;); %&gt;此时跳转到main.jsp中 也就是我们登陆成功后即将要访问的首页 那么现在我们就要解决一个很关键的问题。如果我没有输入用户名和密码我可以进到这个首页吗？答案当然是否定的，所以我们就需要对main.jsp进行过滤。 我们如何进行过滤？我们可以获取我们在login中session中存储的属性获取用户姓名如果姓名字符串长度为0或者为空那么我们可以得出用户并没有输入有效得用户名，他们是没有进入首页得资格的。此时我们就要进行过滤操作，将页面直接跳转到登陆页面并进行标记，告诉用户要先进行登陆 代码以及书写步骤： 创建一个类实现过滤器接口。创建对象 获取session中得属性值，判断是否为null或者长度为0，如果不是，放行。chain.doFilter方法告诉浏览器过滤结束放行。如果是，就回到登录页民重新登陆具体代码： package com.imooc.filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * * @author lv * */ public class SessionFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest hrequest = (HttpServletRequest)request; HttpServletResponse hresponse = (HttpServletResponse)response; String loginUser = (String)hrequest.getSession().getAttribute(&quot;loginUser&quot;); if(loginUser==null||loginUser.length() == 0) { hresponse.sendRedirect(hrequest.getContextPath()+&quot;/index.jsp?flag=1&quot;); return; }else{ chain.doFilter(request, response); return; } } @Override public void init(FilterConfig arg0) throws ServletException { } }别忘了要在xml中注册过滤器 &lt;filter&gt; &lt;filter-name&gt;sessionFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.imooc.filter.SessionFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;sessionFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/main.jsp&lt;/url-pattern&gt;我们此时返回index.jsp中添加一句话。告诉用户重新登陆 &lt;script type=&quot;text/javascript&quot;&gt; var flag = &apos;&lt;%=flag %&gt;&apos;; if(&quot;1&quot;==flag){ alert(&quot;你尚未登陆，或者账号在异地登陆，请重新登陆！&quot;); } &lt;/script&gt;到现在我们就完成了第一个目标 实现了如果用户不登录就无法访问主页的功能，利用的是过滤器的相关知识。那么我们怎么判断该用户登陆过，怎么实现用户信息的存储，怎么实现对已经登陆的用户实现销毁呢我们此时要借助java中的单例模式 保证缓存中只有一个对象单例模式的要点：构造函数的私有化 我们首先建立私有化的构造函数，然后创建一个静态变量，保证只有一个该变量在创建一个共有的静态方法，返回静态变量，返回只有一个。HttpSession对象在创建后，都会有唯一的ID与其他session做标志区别但是不支持通过sessionId获取Session对象我们可以定义两份存储。第一个是存储sessionid和用户登陆名的映射关系第二个是 session和sessionid的映射关系 package com.imooc.cache; import java.util.HashMap; import java.util.Map; import javax.servlet.http.HttpSession; /** 单例模式 * @author lv * */ public class LoginCache { private static LoginCache instance = new LoginCache(); //登陆名与会话id值 private Map&lt;String,String&gt; loginUserSession = new HashMap&lt;String,String&gt;(); private Map&lt;String,HttpSession&gt; loginSession = new HashMap&lt;String,HttpSession&gt;(); //sessionid 和session本身 //通过用户名获得sessionId 通过sessionid 获得对应的session private LoginCache(){ } public static LoginCache getInstance(){//获取实例对象 return instance; } /** * * @param username * @return */ public String getSessionIdByUsername(String username){//sessionid return loginUserSession.get(username); } /** * * @param sessionId * @return */ public HttpSession getSessionBySessionId(String sessionId){//session return loginSession.get(sessionId); } /** * * @param username * @param sessionId */ public void setSessionIdByUserName(String username,String sessionId){//存储操作 loginUserSession.put(username, sessionId); } /** * @param sessionId * @param session */ public void setSessionBySessionId(String sessionId,HttpSession session){//存储 loginSession.put(sessionId, session); } }存储完了下一步就是对每个登陆的对象进行判断看是否之前登陆过此时就要用到监听器的知识。具体用何种监听器呢。每次用户登陆时都要创建一个session属性，所以我们可以使用HttpSessionAttribute Listener 来监听实例对象中属性的创建 创建一个类实现 HttpSessionAttributeListener接口然后在 attributeAdded(HttpSessionBindingEvent hsbe)方法中获取属性名，属性值，再获取当前的session和sessionid 在之前存储用户信息的缓冲区中根据用户名看是否能获取sessionid，如果获取到了证明用户已经登陆，此时要清除旧用户的登陆信息session.invalidate();该方法可以实现注销操作此时再将新用户的 用户名 sessionid session 他们三互相的映射关系存储到相应的集合中，完成用户的新登陆 package com.imooc.listener; import javax.servlet.http.HttpSession; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionBindingEvent; import com.imooc.cache.LoginCache; /** * * @author lv * */ public class LoginSessionListener implements HttpSessionAttributeListener { private static final String LOGIN_USER=&quot;loginUser&quot;; @Override public void attributeAdded(HttpSessionBindingEvent hsbe) { String attrName = hsbe.getName(); if(LOGIN_USER.equals(attrName)){ String attrVal = (String)hsbe.getValue(); HttpSession session = hsbe.getSession(); String sessionId = session.getId(); String sessionId2 = LoginCache.getInstance().getSessionIdByUsername(attrVal);//ֵ if(null == sessionId2){ }else{ HttpSession session2 = LoginCache.getInstance().getSessionBySessionId(sessionId2); session2.invalidate();//注销信息 } LoginCache.getInstance().setSessionIdByUserName(attrVal, sessionId); LoginCache.getInstance().setSessionBySessionId(sessionId, session); } } @Override public void attributeRemoved(HttpSessionBindingEvent arg0) { // TODO Auto-generated method stub } @Override public void attributeReplaced(HttpSessionBindingEvent arg0) { // TODO Auto-generated method stub } }到现在为止我们就完成了目标任务。该程序可以在主页main.jsp和index.jsp中添加css样式进行美化。更好的实现登陆页面功能。 要点 过滤器对目标网站进行过滤，保证了用户正确登陆之后才能进入main.jsp页面。 监听器对对象的添加属性动作进行监听。保证了session中只有一个用户]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>监听器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听器入门]]></title>
    <url>%2F2019%2F09%2F10%2F%E7%9B%91%E5%90%AC%E5%99%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是监听器 监听器是一个专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。监听器其实就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。 java的事件监听机制1、事件监听涉及到三个组件：事件源、事件对象、事件监听器2、当事件源上发生某一个动作时，它会调用事件监听器的一个方法，并在调用该方法时把事件对象传递进去，开发人员在监听器中通过事件对象，就可以拿到事件源，从而对事件源进行操作。 Javaweb监听器 Servlet规范定义的一种特殊类 用于监听ServlertContext，HttpSession，ServletRequest等域对象的创建，销毁及其属性修改发生变化的事件 监听器可以在事件发生前后进行一些必要的处理操作 Javaweb监听器的分类 按监听对象分类 ServletContext对象监听器 HttpSession对象监听器 ServletRequest对象监听器 按监听事件分类 域对象自身的创建和销毁事件监听器 域对象中属性的创建，替换和消除事件 绑定到session中的某个对象的状态事件监听器 1.1监听ServletContext域对象的创建和销毁ServletContextListener接口用于监听ServletContext对象的创建和销毁事件。实现了ServletContextListener接口的类都可以对ServletContext对象的创建和销毁进行监听。 当ServletContext对象被创建时，激发contextInitialized (ServletContextEvent sce)方法。 当ServletContext对象被销毁时，激发contextDestroyed(ServletContextEvent sce)方法。 ServletContext域对象创建和销毁时机：创建：服务器启动针对每一个Web应用创建ServletContext销毁：服务器关闭前先关闭代表每一个web应用的ServletContext 可以在web.xml中初始化参数比如数据库的连接/程序名称/版本号 初始化之后可以通过ContextInitialized方法读取初始化参数 实例：1.首先创建监听器接口实现类 2.然后在xml中注册监听器和配置初始化参数 java类实现ServletContextListener接口： import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; public class MyServletContextListener implements ServletContextListener { @Override public void contextDestroyed(ServletContextEvent sce) { // TODO Auto-generated method stub String appName=(String)sce.getServletContext().getAttribute(&quot;app_name&quot;); String version=(String)sce.getServletContext().getAttribute(&quot;version&quot;); System.out.println(&quot;destory:&quot;+appName +&quot;.&quot;+version); } @Override public void contextInitialized(ServletContextEvent sce) { String appName=sce.getServletContext().getInitParameter(&quot;app_name&quot;); String version=sce.getServletContext().getInitParameter(&quot;version&quot;); sce.getServletContext().setAttribute(&quot;app_name&quot;, appName); sce.getServletContext().setAttribute(&quot;version&quot;, version); System.out.println(&quot;init:&quot;+appName+&quot;,&quot;+version); } }XML配置： &lt;context-param&gt; &lt;param-name&gt;app_name&lt;/param-name&gt; &lt;param-value&gt;Listener Web&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;version&lt;/param-name&gt; &lt;param-value&gt;1.0&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;listener.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt;1.2监听HttpSession域对象的创建和销毁 HttpSessionListener 接口用于监听HttpSession对象的创建和销毁 创建一个Session时，激发sessionCreated (HttpSessionEvent se) 方法 销毁一个Session时，激发sessionDestroyed (HttpSessionEvent se) 方法。 当用于第一次通过浏览器与服务器进行交互的时候，我们的服务器就会创建一个HttpSession对象这个对象就存储着一个对象的专有信息比如用户的登陆名 登陆时间 权限 HttpSession对象相当于一个用户，当创建一个对象就意味着多了一个用户访问销毁要给对象，就相当于一个用户离开 实例：java类实现 HttpSessionListener接口： import java.util.Date; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; public class MyHttpSessionListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent hse) {//创建 // TODO Auto-generated method stub String sessionId=hse.getSession().getId(); Date createTime=new Date(hse.getSession().getCreationTime());//getCreationTime() ，返回SESSION创建时间，从1970年1月1号凌晨开始算起，但其返回值是毫秒，一般需要使用前面的转换来获取具体日期和时间。 System.out.println(sessionId+&quot;，&quot;+createTime); } @Override public void sessionDestroyed(HttpSessionEvent hse) {//销毁 // TODO Auto-generated method stub String sessionId=hse.getSession().getId(); System.out.println(&quot;destory&quot;+sessionId); } }xml Session的默认时间设置是20分钟，即超过20分钟后,服务器会自动放弃Session信息在这里我们给session-timeout设置的事件为1分钟 也就是1分钟之后就自动销毁 &lt;listener&gt; &lt;listener-class&gt;listener.MyHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt; &lt;/session-config&gt;用户访问界面： 当我们访问jsp页面时，HttpSession对象就会创建，此时就可以在HttpSessionListener观察到HttpSession对象的创建过程了，我们可以写一个jsp页面观察HttpSession对象创建的过程。 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;1.3监听ServletRequest域对象的创建和销毁ServletRequestListener接口用于监听ServletRequest 对象的创建和销毁 Request对象被创建时，监听器的requestInitialized(ServletRequestEvent sre)方法将会被调用 Request对象被销毁时，监听器的requestDestroyed(ServletRequestEvent sre)方法将会被调用 ServletRequest域对象创建和销毁时机： 创建：用户每一次访问都会创建request对象 销毁：当前访问结束，request对象就会销毁 请求完成之后生命周期结束，只要对资源服务器有一个请求就会调用监听器 实例import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; import javax.servlet.http.HttpServletRequest; public class MyServletRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { // TODO Auto-generated method stub System.out.println(&quot;destroy&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { // TODO Auto-generated method stub HttpServletRequest request=(HttpServletRequest)sre.getServletRequest();//这里主要是http请求对象 对获得的事件需要转型 String path=request.getRequestURI();//获取路径 String par=request.getParameter(&quot;par&quot;);//获取请求参数 System.out.println(path+&quot;.&quot;+par); } }页面中写一个超链接对网页进行请求创建一个ServletRequest &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;lable&gt; &lt;span&gt;ServletRequestListener测试&lt;/span&gt; &lt;a href=&quot;servlet_request.jsp?par=request_par&quot;target=&quot;_blank&quot;&gt;初始化&lt;/a&gt; &lt;/lable&gt; &lt;/body&gt; &lt;/html&gt;xml中注册监听器 &lt;listener&gt; &lt;listener-class&gt;listener.MyServletRequestListener&lt;/listener-class&gt; &lt;/listener&gt;2.域对象中属性的创建，替换和消除事件监听器域对象中属性的变更的事件监听器就是用来监听 ServletContext, HttpSession, HttpServletRequest 这三个对象中的属性变更信息事件的监听器。 ServletContext——ServletContextAttributeListener HttpSession——HttpSessionAttributeListener ServletRequest——ServletRequestAttributeListener 对每个监听器都有共同的方法,只是接受的参数类型不同。:attributeAdded 属性增加,attributeReplaced 属性替换，attributeRemoved 属性移除 2.1 attributeAdded 方法 当向被监听对象中增加一个属性时，web容器就调用事件监听器的attributeAdded方法进行响应这个方法接收一个事件类型的参数，监听器可以通过这个参数来获得正在增加属性的域对象和被保存到域中的属性对象 各个域属性监听器中的完整语法定义为： public void attributeAdded(ServletContextAttributeEvent scae) public void attributeReplaced(HttpSessionBindingEvent hsbe) public void attributeRmoved(ServletRequestAttributeEvent srae) 2.2 attributeRemoved 方法 当删除被监听对象中的一个属性时，web容器调用事件监听器的attributeRemoved方法进行响应 各个域属性监听器中的完整语法定义为： public void attributeRemoved(ServletContextAttributeEvent scae) public void attributeRemoved (HttpSessionBindingEvent hsbe) public void attributeRemoved (ServletRequestAttributeEvent srae) 2.3、attributeReplaced 方法 当监听器的域对象中的某个属性被替换时，web容器调用事件监听器的attributeReplaced方法进行响应 各个域属性监听器中的完整语法定义为： public void attributeReplaced(ServletContextAttributeEvent scae) public void attributeReplaced (HttpSessionBindingEvent hsbe) public void attributeReplaced (ServletRequestAttributeEvent srae) 以ServletContextAttributeListener为例,其他的两个监听器同理： 在java类中继承ServletContextAttributeListener接口 import javax.servlet.ServletContextAttributeEvent; import javax.servlet.ServletContextAttributeListener; public class MyServletContextAttribute implements ServletContextAttributeListener { @Override public void attributeAdded(ServletContextAttributeEvent scae) { // TODO Auto-generated method stub System.out.println(scae.getName()+&quot;,&quot;+scae.getValue()); } @Override public void attributeRemoved(ServletContextAttributeEvent scae) { // TODO Auto-generated method stub System.out.println(&quot;remove&quot;+scae.getName()+&quot;,&quot;+scae.getValue()); } @Override public void attributeReplaced(ServletContextAttributeEvent scae) { // TODO Auto-generated method stub System.out.println(scae.getName()+&quot;,&quot;+scae.getValue()); } }测试页面jsp中添加属性 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;% application.setAttribute(&quot;servletcontextPar&quot;,&quot;servletcontext_par&quot;);//添加属性 application.setAttribute(&quot;servletcontextPar&quot;,&quot;servletcontext_par1&quot;);//替换属性 application.removeAttribute(&quot;servletcontextPar&quot;);//移除属性 %&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;dffd&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;xml &lt;listener&gt; &lt;description&gt;MyServletContextAttributeListener监听器&lt;/description&gt; &lt;listener-class&gt;listener.MyServletContextAttribute&lt;listener-class&gt; &lt;/listener&gt;3.绑定到session中的某个对象的状态事件监听器Servlet 规范中定义了两个特殊的监听器接口”HttpSessionBindingListener和HttpSessionActivationListener”来帮助JavaBean 对象了解自己在Session域中的这些状态： ，实现这两个接口的类不需要 web.xml 文件中进行注册。 用户登陆就注册session,用户退出就解绑session valueBound（HttpSessionBindingEvent event）当监听器对象绑定至Http会话调用 valueUnbound(HttpSessionBindingEvent event) 当监听器对象从HTTP会话内修改移除或会话销毁时调用 实现了HttpSessionBindingListener接口的JavaBean对象可以感知自己被绑定到Session中和 Session中删除的事件. 当对象被绑定到HttpSession对象中时，web服务器调用该对象的void valueBound(HttpSessionBindingEvent event)方法. 当对象从HttpSession对象中解除绑定时，web服务器调用该对象的void valueUnbound(HttpSessionBindingEvent event)方法. 继承HttpSessionBindingListener的java package com.imooc.listener; import javax.servlet.http.HttpSessionBindingEvent; import javax.servlet.http.HttpSessionBindingListener; public class User implements HttpSessionBindingListener { private String username; private String password; @Override public void valueBound(HttpSessionBindingEvent hsbe) { // TODO Auto-generated method stub String name=hsbe.getName();//返回发生绑定对象的名字 System.out.println(&quot;value bound name:&quot;+name); } @Override public void valueUnbound(HttpSessionBindingEvent hsbe) { // TODO Auto-generated method stub String name=hsbe.getName();//返回取消绑定的对象的名字 System.out.println(&quot;value unbound name:&quot;+name); } }页面设置 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;lable&gt; &lt;span&gt;测试&lt;/span&gt; &lt;a href=&quot;bound.jsp&quot;target=&quot;_blank&quot;&gt;绑定&lt;/a&gt; &lt;a href=&quot;unbound.jsp&quot;target=&quot;_blank&quot;&gt;接触绑定&lt;/a&gt; &lt;/lable&gt; &lt;/body&gt; &lt;/html&gt;bound.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% session.setAttribute(&quot;user&quot;,new listener.User());//绑定 //session.removeAttribute(&quot;user&quot;);//解除绑定 %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;bound&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>监听器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤器入门]]></title>
    <url>%2F2019%2F09%2F10%2F%E8%BF%87%E6%BB%A4%E5%99%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是过滤器FilterFilter就是英文的过滤器，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 如何实现Filter1.创建的java类实现Filter接口. Filter接口中有三个方法： default void init(FilterConfig filterConfig) void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) default void destroy() 其中init初始化和销毁destroy是默认实现的，我们无需重写 doFilter 是一个核心方法，我们必须要实现。 关于doFilter方法：doFilter方法是filter接口中的核心方法，一旦创建完该过滤器的实例之后，会执行dofilter方法。主要有三个参数，第一个参数是一个ServletRequest对象，HttpServletRequest继承于此接口，当用户请求某个拦截器的时候，检测到此请求存在过滤器，于是会封装好本次请求的相关数据，传递给dofilter的ServletRequest参数，ServletResponse参数的来源和ServletRequest是一样的，都是由客户端封装过来的。第三个参数 2.在web.xml文件中对filter类进行注册。并设置它所要拦截的资源&lt;!--配置过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.CharacterEncoding&lt;/filter-class&gt; &lt;/filter&gt; &lt;!--映射过滤器--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;实例：/** * 字符集编码过滤器 */ import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class CharacterEncodingFilter implements Filter { @Override public void destroy() { System.out.println(&quot;----过滤器销毁----&quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(&quot;UTF-8&quot;); // System.out.println(&quot;characterEncodingFilter 请求预 处理&quot;);//测试过滤器（链）工作流程使用 chain.doFilter(request, response);//让目标资源执行放行 // System.out.println(&quot;characterEncodingFilter 响应后处理&quot;);//测试过滤器（链）工作流程使用 } @Override public void init(FilterConfig config) throws ServletException { System.out.println(&quot;----过滤器初始化----&quot;); } }chain.doFilter(request, response)关于过滤链： 在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。Web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。 xml配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 过滤器注册--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.CharacterEncoding&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt;Fliter的生命周期 web应用程序启动时，web服务器创建Filter的实例对象。以及对象的初始化 当请求访问与过滤器关联的Web资源时，过滤器拦截请求，完成指定的功能 Filter对象创建会驻留在内存，在web应用移除或者服务器停止的时候才会销毁 过滤器的创建和销毁由服务器负责。 FilterConfig接口用户在配置filter时，可以使用为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得： String getFilterName()：得到filter的名称。 String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。 public ServletContext getServletContext()：返回Servlet上下文对象的引用。 实例:import java.io.IOException; import java.util.Enumeration; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class FilterDemo02 implements Filter { /* 过滤器初始化 * @see javax.servlet.Filter#init(javax.servlet.FilterConfig) */ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(&quot;----过滤器初始化----&quot;); //得到过滤器的名字 String filterName = filterConfig.getFilterName(); //得到在web.xml文件中配置的初始化参数 String initParam1 = filterConfig.getInitParameter(&quot;name&quot;); String initParam2 = filterConfig.getInitParameter(&quot;like&quot;); //返回过滤器的所有初始化参数的名字的枚举集合。 Enumeration&lt;String&gt; initParameterNames = filterConfig.getInitParameterNames(); System.out.println(filterName); System.out.println(initParam1); System.out.println(initParam2); while (initParameterNames.hasMoreElements()) { String paramName = (String) initParameterNames.nextElement(); System.out.println(paramName); } } @Override public void doFilter(ServletRequest request, ServletResponse response, System.out.println(&quot;FilterDemo02执行前！！！&quot;); chain.doFilter(request, response); //让目标资源执行，放行 System.out.println(&quot;FilterDemo02执行后！！！&quot;); } @Override public void destroy() { System.out.println(&quot;----过滤器销毁----&quot;); } }xml 配置： &lt;filter&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;!--配置FilterDemo02过滤器的初始化参数--&gt; &lt;init-param&gt; &lt;description&gt;配置FilterDemo02过滤器的初始化参数&lt;/description&gt; &lt;param-value&gt;gacl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;description&gt;配置FilterDemo02过滤器的初始化参数&lt;/description&gt; &lt;param-name&gt;like&lt;/param-name&gt; &lt;param-value&gt;java&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;Fileter 的部署： 注册Filter 映射Filter 注册Filter： FilterDemo02过滤器 FilterDemo02 me.gacl.web.filter.FilterDemo02 配置FilterDemo02过滤器的初始化参数 name gacl 配置FilterDemo02过滤器的初始化参数 like java &lt;description&gt; 用于添加描述信息，该元素的内容可为空，&lt;description&gt;可以不配置。 用于为过滤器指定一个名字，该元素的内容不能为空。 元素用于指定过滤器的完整的限定类名。 元素用于为过滤器指定初始化参数，它的子元素指定参数的名字，指定参数的值。在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。如果过滤器不需要指定初始化参数，那么元素可以不配置。 映射Filter &lt;!--映射过滤器--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径 子元素用于设置filter的注册名称。该值必须是在元素中声明过的过滤器的名字 设置 filter 所拦截的请求路径(过滤器关联的URL样式) 指定过滤器所拦截的Servlet名称。 指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个 子元素用来指定 Filter 对资源的多种调用方式进行拦截。 java的4种过滤器： REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。 配置如下： &lt;filter-mapping&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-两数之和]]></title>
    <url>%2F2019%2F09%2F08%2Fleetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[开始刷leetcode啦！加油加油！ 题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思想刚开始想的特别简单就是在给定数组中进行遍历，两层for循环看看两个数相加是否可以==target，如果有的话直接返回当时的ij值 代码如下public class Solution { public int[] twoSum(int[] nums, int target) { int[] arr=new int[2]; for(int i=0;i&lt;nums.length-1;i++){ for(int j=i+1;j&lt;nums.length;j++){ if(nums[i]+nums[j]==target){ return new int[]{i,j}; } } } return arr; } }当时显示的是：用时54ms 内存消耗38.4MB； 后来又看到了大佬的代码 这道题的标签时数组和哈希表我当时并没有想到可以用hashMap;看完大佬的代码才反应过来这样只需要一层循环，时间肯定可以减少不少 思路：先建一个map集合。然后遍历整个nums数组，在该组数中先看每一个nums[i]的值，如果target-nums[i]存在，就证明这两个数相加等于target.如果不存在就直接保存num[i]和对应的索引值i，这点用的比较巧妙。一边找一边存，每次寻找只需要寻找之前遍历过的nums[]里面的值,看是否有等于target-nums[i]即可。 代码如下：public class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++){ Integer index=map.get(target-nums[i]); if(index==null){ map.put(nums[i],i); }else{ return new int[]{i,index}; } } return new int[]{0,0}; } }此时显示执行用时9ms，内存消耗39Mz，时间上大大减少了。代码算法优化简直太重要啦]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是正则表达式 正则表达式是检查，匹配字符串的表达式 正则表达式是描述规则，主流语言都有很好的支持 字符串校验，查找与替换是正则表达式主要使用场景 字符范围的匹配 A 精准匹配单个字符 x|y 允许出2个字符 [xyz]字符集和，允许出现集合内任意单个字符 [a-z] [A-z] [0-9] 字符范围 [^xyz] [^0-9] 集合中字符不允许出现 ^ 这个符号相当于取反 也就是不能有这个符号后面的字符 练习：精准匹配字符串“hallo”或者“hello” h[ae]llo 请匹配数字范围（0570-0579) [0570-0579]或者 057[0-9] 单选题只允许输入ABCD其中一项[ABCD] [A-D] 元字符 所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符(即位于元字符前面的字符)在目标对象中的出现模式元字符是一个或一组代替一个或多个字符的字符。 \d 匹配任意单个数字 \D 匹配\d规则之外的任意单个字符 \w 匹配任意单个字母，数字，下划线 \W 匹配\w之外的任意单个字符 \s 匹配单个空格 \n 匹配单个换行符 . 匹配任意单个字符(换行符除外） \. 特殊字符，只匹配 练习 匹配数字3213.383219 如果写成\d\d\d\d.\d\d\d\d\d\d那么当写成1234A456878 也同样可以匹配上 因为.代表了任意字符所以应该\d\d\d\d.\d\d\d\d\d\d 加一个\令它原义输出 匹配杭州与宁波座机号码（0571|0574-XXXXXXXX) 057[14]-\d\d\d\d\d\d\d\d 请匹配18位身份证号 因为身份证第一位不能079。所以答案[1234568]\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d[0-9xX] 多次重复匹配 A{3} 精准的N次匹配 （正确：AAA；错误：AA） A{3,} 最少出现N次 （正确：AAA；错误：AA） \d{3,5} 出现最大次数与最小次数，所以最大5，最小3 （正确：1234；错误：12） \d* 可以出现零次至无限次相当于{0，}（正确12345；） \d+ 最少出现一次，相当于{1，} （正确：12；错误： ） \d? 至多出现一次相当于{0，1} （正确：1；错误：22） 练习 验证短信验证码（6位数字) \d{6} 请匹配全国座机号(区号3或者4位-电话号7或者8位) \d{3,4}-\d{7,8} 匹配英文姓名 [A-Z][a-z]+\s[A-Z][a-z]* 定位匹配 ^A.* 头匹配 （正确：ABC；错误：CBA） .*A$ 尾匹配 （正确：CBA；错误：ABC） ^A.*A$ 全字匹配 （正确：ACCCA;错误：ACCB） 贪婪模式与非贪婪模式 贪婪模式：在满足条件情况下尽可能多匹配 非贪婪模式：在满足条件情况下尽可能少匹配 举例：对于 11221111 这个字符串 如果表达式是 \d{6,8} 会匹配到11221111 但是如果是 \d{6,8}? 则会匹配到 112211 所以在正则表达时描述数量的地方后面加一个？ 即可变成非贪婪模式 练习&lt;a href=”www.baidu.com&quot;\&gt;百度&lt;/a&gt;&lt;a href=”www.sina.com&quot;\&gt;新浪&lt;/a&gt; 如果输入“.*”匹配结果：”www.baidu.com&quot;&gt;百度&lt;a href=”www.baidu.com&quot; “.*？” （？写在描述数量的后面）匹配结果： 2处匹配 “www.baidu.com&quot; “www.sina.com&quot; 表达式分组将子表达式进行包裹用小括号 练习匹配验证码(4或者6位) (^\d{4}$)|(^\d{6}$) 匹配车牌号（冀A-U888G) ^([冀黑粤晋][A-Z])-([A-Z0-9]{5})$ 匹配中文或英文姓名 (^[\u4e00-\u9fa5]{2,8}$)|(^[A-Z][a-z]+\s[A-Z][a-z]*$) javascript 表单的验证步骤： 先定义正则表达式 利用正则表达式的test()方法对要验证的字符串进行检查 如果匹配则返回true 如果不匹配则返回false 实例&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;#&quot; id=&quot;frmInfo&quot;&gt; &lt;div id=&quot;err&quot; style=&quot;color:red&quot;&gt; &lt;/div&gt; &lt;div&gt;姓名:&lt;input id=&quot;name&quot; name=&quot;name&quot;/\&gt;&lt;/div&gt; &lt;div&gt;身份证:&lt;input id=&quot;idno&quot; name=&quot;idno&quot;/\&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;submit&quot; &gt;&lt;/div&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;frmInfo&quot;).onsubmit=function() { //在JS中定义正则表达式对象只需要在/正则表达式/ var regex1=/^[\u4e00-\u9fa5]{2,8}$/; var regex2=/^[1234568]\d{16}[0-9Xx]$/; var name=document.getElementById(&quot;name&quot;).value; var idno=document.getElementById(&quot;idno&quot;).value; if(regex1.test(name)==false) { document.getElementById(&quot;err&quot;).innerHTML=&quot;无效姓名&quot;; return false; } else if(regex2.test(idno)==false) { document.getElementById(&quot;err&quot;).innerHTML=&quot;无效身份证&quot;; return false; } else { alert(&quot;正在提交&quot;); return true; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;java中web页面信息的提取网页信息 &lt;!DOCTYPEhtml&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;国际主要城市&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;国际主要城市&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;纽约NewYork&lt;/li&gt; &lt;li&gt;伦敦London&lt;/li&gt; &lt;li&gt;东京Tokyo&lt;/li&gt; &lt;li&gt;巴黎Paris&lt;/li&gt; &lt;li&gt;香港HongKong&lt;/li&gt; &lt;li&gt;新加坡Singapore&lt;/li&gt; &lt;li&gt;悉尼Sydney&lt;/li&gt; &lt;li&gt;米兰Milano&lt;/li&gt; &lt;li&gt;上海Shanghai&lt;/li&gt; &lt;li&gt;北京Beijing&lt;/li&gt; &lt;li&gt;马德里Madrid&lt;/li&gt; &lt;li&gt;莫斯科Moscow&lt;/li&gt; &lt;li&gt;首尔Seoul&lt;/li&gt; &lt;li&gt;曼谷Bangkok&lt;/li&gt; &lt;li&gt;多伦多Toronto&lt;/li&gt; &lt;li&gt;布鲁塞尔Brussels&lt;/li&gt; &lt;li&gt;芝加哥Chicago&lt;/li&gt; &lt;li&gt;吉隆坡KualaLumpur&lt;/li&gt; &lt;li&gt;孟买Mumbai&lt;/li&gt; &lt;li&gt;华沙Warsaw&lt;/li&gt; &lt;li&gt;圣保罗SaoPaulo&lt;/li&gt; &lt;li&gt;苏黎世Zurich&lt;/li&gt; &lt;li&gt;阿姆斯特丹Amsterdam&lt;/li&gt; &lt;li&gt;墨西哥城MexicoCity&lt;/li&gt; &lt;li&gt;雅加达Jakarta&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;下面的程序要从上面的网页中提取信息 首先我们要创建正则表达式对象： Pattern p=Pattern.compile(“&lt;li&gt;([\u4e00-\u9fa5]{2,})([A-Za-z]+)&lt;/li&gt;“);里面规定了正则表达式 定义一个匹配器对象，Matcher m=p.matcher(content) matcher方法返回一个匹配器对象 用m.find()方法判断是否可以匹配如果可以匹配则返回true ，否者返回false，对于那些成功匹配的可以输出出来 输出的时候 group(0)提取完整的字符串。如果正则表达式事先进行了分组，那么group(1)则输出第一个分组，group(2)则输出第二个分组，依次类推。 具体代码如下： import java.io.BufferedReader; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStreamReader; import java.io.UnsupportedEncodingException; import java.util.regex.Matcher; import java.util.regex.Pattern; public class Regex { public static void main(String[] args) throws IOException { StringBuilder content =new StringBuilder(); FileInputStream fis=new FileInputStream(&quot;E:\\eclipse\\regex\\WebContent\\NewFile.html&quot;); InputStreamReader isr=new InputStreamReader(fis,&quot;UTF-8&quot;);//转换流 BufferedReader BufferedReader =new BufferedReader (isr); String lineText=&quot;&quot;; while((lineText = BufferedReader.readLine())!=null) { //System.out.println(lineText); content.append(lineText); } BufferedReader.close(); Pattern p=Pattern.compile(&quot;&lt;li&gt;([\\u4e00-\\u9fa5]{2,})([A-Za-z]+)&lt;/li&gt;&quot;);//创建正则表达式对象 Matcher m=p.matcher(content);//matcher方法进行匹配返回一个匹配器对象 while(m.find())//在原始字符串查找如果匹配成功就可以提取出来 { //用group(0) 提取完整字符串 System.out.printf(m.group(1)); System.out.println(m.group(2)); } } }]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX项目-二级联动菜单的设置]]></title>
    <url>%2F2019%2F09%2F06%2FAJAX%E9%A1%B9%E7%9B%AE--%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8%E8%8F%9C%E5%8D%95%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[介绍二级联动的菜单在网页中很常见，通常是通过鼠标点一级菜单的相关内容之后二级菜单做出响应变化显示出一级菜单对应的子菜单。我这次是用AJAX的相关知识进行实现。 我的思路：1.首先我构造了一个类Channel目的就是为了为每个菜单添加名字和内容的两个属性。 2.在网页初初始化时候我们要对一级菜单进行显示，也就是向servlet中传递一个level=1的变量当服务器接收到level=1时 将一级菜单里面的内容通过json转为字符串传回到之前的html中通过javascript的AJax方法解析后，将内容放到对应html中的下拉表单中显示出来。 3.利用Ajax的动态更新，可以实时实现二级菜单的更新。因为每个一级菜单都对应一个二级菜单。所以在跟新二级菜单时候可以根据一级菜单每个菜单栏的名字去寻找。那么此时我们需要一个事件，也就是发生什么事件之后对二级菜单进行更新，这个事件就是鼠标点击事件，根据鼠标点击一级菜单的哪个菜单项获取对应的菜单项的属性名，传到服务器上，服务器可以根据这个属性名来判断传送这个一级菜单对应哪个二级菜单，判断后用json方法转为字符串传到html中。再根据AJax方法解析后，将内容放到对应html中的下拉表单中显示出来，从而动态显示二级菜单。 package com.ajax; public class Channel { private String name; private String code; public Channel() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public Channel(String name, String code) { super(); this.name = name; this.code = code; }}sevlet代码： import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class ChannelServlet */ @WebServlet(&quot;/channel&quot;) public class ChannelServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ChannelServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub String level=request.getParameter(&quot;level&quot;); String parent=request.getParameter(&quot;parent&quot;); List channelist= new ArrayList(); if(level.equals(&quot;1&quot;)) { channelist.add(new Channel(&quot;ai&quot;,&quot;前端/区块链/人工智能&quot;)); channelist.add(new Channel(&quot;web&quot;,&quot;前端/小程序/js&quot;)); } if(level.equals(&quot;2&quot;)) { if(parent.equals(&quot;ai&quot;)) { channelist.add(new Channel(&quot;micro&quot;,&quot;微服务&quot;)); channelist.add(new Channel(&quot;blocklist&quot;,&quot;区块链&quot;)); channelist.add(new Channel(&quot;other&quot;,&quot;。。。&quot;)); } else if (parent.equals(&quot;web&quot;)) { channelist.add(new Channel(&quot;html&quot;,&quot;HTML&quot;)); channelist.add(new Channel(&quot;css&quot;,&quot;CSS&quot;)); channelist.add(new Channel(&quot;other&quot;,&quot;。。。&quot;)); } } String json=JSON.toJSONString(channelist); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(json); } } &lt;!--html代码:--&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){//初始化显示一级菜单 $.ajax({ &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:{&quot;level&quot;:&quot;1&quot;}, &quot;dataType&quot;:&quot;json&quot;, &quot;type&quot;:&quot;get&quot;, &quot;success&quot;:function(json) { for(var i=0;i&lt;json.length;i++) { var ch=json[i]; $(&quot;#lv1&quot;).append(&quot;&lt;option value=&apos;&quot;+ch.name +&quot;&apos;&gt;&quot;+ch.code+&quot;&lt;/option&quot;); } } }) }) $(function(){//二级菜单 $(&quot;#lv1&quot;).click(function(){ var parent=$(this).val(); $.ajax({ &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:{&quot;level&quot;:&quot;2&quot;,&quot;parent&quot;:parent}, &quot;dataType&quot;:&quot;json&quot;, &quot;type&quot;:&quot;get&quot;, &quot;success&quot;:function(json) { $(&quot;#lv2&gt;option&quot;).remove(); for(var i=0;i&lt;json.length;i++) { var ch=json[i]; $(&quot;#lv2&quot;).append(&quot;&lt;option value=&apos;&quot;+ch.name +&quot;&apos;&gt;&quot;+ch.code+&quot;&lt;/option&quot;); } } }) }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;select id=&quot;lv1&quot; style=&quot;width:200px;height:30px&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;请选择&lt;/option&gt;//带有预先设置的下拉框 &lt;/select&gt; &lt;select id=&quot;lv2&quot; style=&quot;width:200px;height:30px&quot;&gt;&lt;/select&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>-AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX的入门学习]]></title>
    <url>%2F2019%2F09%2F06%2FAJAX%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[AJAX介绍 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 AJAX工作原理 AJAX的使用流程1.创建XMLHttpRequest对象 var xmlhttp; if(window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 var xmlhttp=new XMLHttpRequest; } else { // IE6, IE5 浏览器执行代码 var xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); }2.发送Ajax请求 xmlhttp.open(“GET”,”url”,”true); xmlhttp.send(); open(method,url,async):规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步） 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true； 同步执行：同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回这个期间客户端浏览器不能干任何事代码进入一个等待的时候，数据不返回时不会向下执行 异步执行：异步:请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕不会处于堵塞的 会一直向下执行，但是数据的返回时候触发onreadystatechange事件来完成注意：当使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可。 实际使用时 ajax推荐使用异步 实例： 服务器响应代码： import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class NewListServlet */ @WebServlet(&quot;/newslist&quot;) public class NewListServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public NewListServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub try { Thread.sleep(5000);//等待事件5000秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } List list=new ArrayList(); list.add(new News(&quot;TIOBE:2018年5月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年6月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年7月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年8月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年9月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); String json=JSON.toJSONString(list); System.out.println(json); response.setContentType(&quot;text/html ; charset=utf-8&quot;); response.getWriter().println(json); } }同步：var xmlhttp; if(window.XMLHttpRequest) { xmlhttp=new XMLHttpRequest(); } else { xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.open(&quot;GET&quot;,&quot;/ajax/newslist&quot;,false); xmlhttp.send(); console.log(&quot;请求发送完成&quot;); if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) { var t=xmlhttp.responseText; console.log(t); var json=JSON.parse(t); console.log(json); var html=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { var news=json[i]; html=html+&quot;&lt;h1&gt;&quot;+news.title+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;h2&gt;&quot;+news.date+&quot;&amp;nbsp;&quot;+news.source+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;hr/&gt;&quot;; } document.getElementById(&quot;container&quot;).innerHTML=html; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; xmlhttp.send();该程序会先等待当等待5000秒，5000秒后才输出请求发送完成和现显示响应内容。 异步：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var xmlhttp; if(window.XMLHttpRequest) { xmlhttp=new XMLHttpRequest(); } else { xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.open(&quot;GET&quot;,&quot;/ajax/newslist&quot;,true); xmlhttp.send(); console.log(&quot;请求发送完成&quot;); xmlhttp.onreadystatechange=function()//异步获取数据方法 { if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) { var t=xmlhttp.responseText; console.log(t); var json=JSON.parse(t); console.log(json); var html=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { var news=json[i]; html=html+&quot;&lt;h1&gt;&quot;+news.title+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;h2&gt;&quot;+news.date+&quot;&amp;nbsp;&quot;+news.source+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;hr/&gt;&quot;; } document.getElementById(&quot;container&quot;).innerHTML=html; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;执行完会立刻发送一个“请求发送完成字样 然后过5000秒后显示响应内容3.处理服务器的响应 xmlhttp.onreadystatechange()事件用于监听AJAX的执行过程 xmlhttp.readyState属性说明XMLHttpRequest当前状态 readyState=0 请求未初始化 readyState=1 服务器连接已建立 readyState=2 请求已经被接收 readyState=3 请求正在处理 readyState=4 相应文本已经接收 xmlhttp.status属性服务器响应状态码，200：成功。400没有找到。 xmlhttp.onreadystatechange=funcition(){ if(xmlhttp.readyState==4&amp;&amp;xml.status==200){ //获取相应体的文本var responseText=xmlhttp.responseText; } } jQuery对Ajax的支持 url:发送请求地址 type:请求类型get/post datatype:服务器响应的数据类型text|json|xml|html|jsonp|script data:向如武器传递的参数 success ：接收响应时的处理函数 error ：请求失败时处理的函数 async: 要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。 实例： import java.util.List; import java.io.IOException; import java.util.ArrayList; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class ZUOYE */ @WebServlet(&quot;/zuoye&quot;) public class ZUOYE extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ZUOYE() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub response.setContentType(&quot;text/html ; charset=utf-8&quot;); String tt=request.getParameter(&quot;t&quot;); List list=new ArrayList(); list.add(&quot;稻香&quot;); list.add(&quot;晴天&quot;); list.add(&quot;告白气球 &quot;); List list2=new ArrayList(); list2.add(&quot;千千阕歌&quot;); list2.add(&quot;傻女&quot;); list2.add(&quot;七友 &quot;); List list3=new ArrayList(); list3.add(&quot;一块红布&quot;); list3.add(&quot;假行僧&quot;); list3.add(&quot;新长征路上的摇滚 &quot;); int m=Integer.parseInt(tt); if(m==1) { String json=JSON.toJSONString(list); response.getWriter().println(json); } else if(m==2) { String json2=JSON.toJSONString(list2); response.getWriter().println(json2); } if(m==3) { String json3=JSON.toJSONString(list3); response.getWriter().println(json3); } } } ajax代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; input { width:33%; text-align:center; font-weight:bold;} div { margin-left:50%; width:100px; margin-top:200px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;b1&quot; value=&quot;流行歌曲&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;b2&quot; value=&quot;经典歌曲&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;b3&quot; value=&quot;摇滚歌曲&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;input[id=&apos;b1&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=1&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json) { console.log(json); var s=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); $(&quot;input[id=&apos;b2&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=2&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)//已经变成了json无需进行字符串的转化 { var s=&quot;&quot;; console.log(json); for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); $(&quot;input[id=&apos;b3&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=3&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)//已经变成了json无需进行字符串的转化 { console.log(json); var s=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;结果：]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的入门学习]]></title>
    <url>%2F2019%2F09%2F05%2FJQuery%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[jQuery的介绍与下载安装 什么是jQuery jQuery是一个快速、简洁的JavaScript框架，它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。jQuery的核心特性可以总结为:具有独特的链式语法和短小清晰的多功能接口;具有高效灵活的css选择器，并且可对CSS选择器进行扩展;拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。 jQuery 下载 jQuery官网下载最新版本将下载好的jQuery放在WebContent里面 jQuery采用独立的JS文件发布 IDE:Eclipse，Hbuilder，sublime，webstorm jQuery基础语法 jQuery 选择器允 许您对 HTML 元素组或单个元素进行操作。jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”(或选择)HTML 元素。 它基于已经存在的CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头:$()。 文档就绪事件入口函数$(document).ready(function(){ // 开始写 jQuery 代码... });简写： $(function(){ // 开始写 jQuery 代码... });这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。如果在文档没有完全加载之前就运行函数，操作可能失败。 jQuery 入口函数与 JavaScript 入口函数的区别： jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行 基本选择器 1.$(“#id”)–ID选择器，指定Id元素对象 2.$(“标签”)–元素选择器，选择指定标签名的选择器 3.$(“.class”)–类选择器，选中拥有指定css类的元素 4.$(“S1,S2,S3”)组合选择器，对元素进行组合 层叠选择器$(“ancestor descendant”) 后代选择器 $(“ancestor&gt;descendant”)子选择器$(“prev ~ siblings”)兄弟选择器 后代选择器与子选择器最大的区别就是后代选择器可以选择该节点之后的所有节点而子选择器只能选择该节点的一个子节点。兄弟选择器是选择节点之后所有符合要求的平级节点 属性选择器 $(“selector[attribute=value]”)选中属性值等于具体值的组件 $(“selector[attribute^=value]”)选中属性值以某值开头的组件 $(“selector[attribute$=value]”)选中属性值以某值结尾的组件 $(“selector[attribute * =value]”)选中属性值包含某值的组件 位置选择器$(“selector:first”)获取第一个元素 $(“selector:last”)获取最后一个元素 $(“selector:even”)获取偶数的元素（从0开始） $(“selector:odd”)获取奇数位置的元素（从0开始） $(“selector:eq(n)”)获取指定位置的元素（从0开始） 表单选择器 $(“selector:input”)所有的输入元素 $(“selector:text”)所有的文本框 $(“selector:password”)获取密码框 $(“selector:submit”)获取提交按钮 $(“selector:reset) 获取重置按钮 操作元素的属性-attr(name|properties|key) 获取或者设置元素属性 -removeAttr(name) 移除元素属性 如果attr() 括号中有一个元素就是获取属性如果有两个就是更改属性 var href_attr=$(&quot;a[href*=&apos;163&apos;]&quot;).attr(&quot;href&quot;);//获取元素 alert(href_attr); $(&quot;a[href*=&apos;163&apos;]&quot;).attr(&quot;href&quot;,&quot;http://www.163.com&quot;);//更改元素 $(&quot;a&quot;).removeAttr(&quot;href&quot;);//移除属性，此时a标签不再有超链接属性操作元素的CSS属性 css()获取设置匹配元素样式属性 addClass() 为每个匹配的元素添加指定的类名 removeClass() 为所有匹配的元素中删除全部或者指定的类 $(&quot;a&quot;).css(&quot;color&quot;,&quot;red&quot;);//设置a标签中的文字是红色 var color=$(&quot;a&quot;).css(&quot;color&quot;);//获取a标签的颜色 alert(color); $(&quot;a&quot;).css({&quot;color&quot;:&quot;red&quot;,&quot;font-weight&quot;:&quot;bold&quot;,&quot;font-size&quot;:&quot;italic&quot;});//多个属性的设置 可以使用json表达式 $(&quot;li&quot;).addClass(&quot;highlight myclass&quot;);//添加类 $(&quot;p&quot;).removeClass(&quot;myclass&quot;);//移除类 设置元素内容-val() 获取或者设置输入项的值-text()获取或设置元素的纯文本-html() 获取或设置元素内容的HTML $(&quot;input[name=&apos;uname&apos;]&quot;).val(&quot;administrator&quot;);//设置 var s=$(&quot;input[name=&apos;uname&apos;]&quot;).val();//获取text与html中 最大的区别是对文本中的html标签是否进行转义一般用text方法对纯文本进行设置和获取 var ss=$(“span.myclass”).html(); var ss=$(“span.myclass”).text();//获得纯文本 一般用text方法对纯文本进行设置和获取 jQuery事件处理方法jQuery 事件方法语法在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。 页面中指定一个点击事件： $(&quot;p&quot;).click();下一步是定义什么时间触发事件。您可以通过一个事件函数实现： $(&quot;p&quot;).click(function(){ // 动作触发后执行的代码!! }); click()click() 方法是当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。 dblclick()当双击元素时，会发生 dblclick 事件。 mouseenter()当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseleave()当鼠标指针离开元素时，会发生 mouseleave 事件。mouseleave() 方法触发 mouseleave 事件， mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数 mouseup()当在元素上松开鼠标按钮时，会发生 mouseup 事件。mouseup() 方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数： hover()hover()方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 focus()当元素获得焦点时，发生 focus 事件。当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数： blur()当元素失去焦点时，发生 blur 事件。blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数： $(&quot;p.myclass&quot;).click(function(){ $(this).css(&quot;background-color&quot;,&quot;green&quot;);//此时myclass的背景色变为绿色 });jQuery效果- 隐藏和显示jQuery hide() 和 show() 通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： $(&quot;#hide&quot;).click(function(){ $(&quot;p&quot;).hide(); }); $(&quot;#show&quot;).click(function(){ $(&quot;p&quot;).show(); });]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON入门学习]]></title>
    <url>%2F2019%2F08%2F31%2FJSON%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是JSON 是一种轻量级的数据交换格式。他基于 javascript 语法的子集，即数组和对象表示。 采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率. 客户端向服务器端发送请求后，服务器端怎么才能把用户需要的数据返回给客户端呢。这时我们就需要用一个指定的格式将数据，按照指定格式返回客户端。这时就有了两种数据传输的方式（XML和Json),在普通的Web应用中，不管是服务器端还是客户端解析XML代码会非常麻烦，所以这时Json就更加满足数据传输解析的要求。采用Json格式的方式进行数据的传输，不仅方便传输解析，还特别易于人阅读和编写 JSON的语法规则 数据由键(key),值(value)描述,由逗号分隔 大括号代表一个完整的对象,又有多个键/值对 中括号保存数组,多个对象之间使用逗号分割 #####注意:key和value如果是字符串的时候一定要有引号 ###JSON实例利用JSON存储员工信 JSON: [ { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;李宁&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot; }, { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;张三&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot;, &quot;customers&quot;: [ { &quot;cname&quot;: &quot;李东&quot; }, { &quot;canme&quot;: &quot;王五&quot; } ] } ]可以用JSON来代替xmlxml&lt;student name=&quot;xiaoming&quot;&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;age&gt;26&lt;/age&gt; &lt;/student&gt; 替代后[{&quot;name&quot;:&quot;xiaoming&quot;,&quot;sex&quot;:&quot;female&quot;,&quot;age&quot;:&quot;26&quot;}]javascripe访问JSON对象JSON就相当于一个大数组,在javasripe中我们用访问数组的方式访问JSON就可以.一下是实例:&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; json是一个数组里面有各个对象的信息 var json= [ { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;李宁&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot; }, { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;张三&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot;, &quot;customers&quot;: [ { &quot;cname&quot;: &quot;李东&quot; }, { &quot;cname&quot;: &quot;王五&quot; } ] } ]; for(var i=0;i&lt;json.length;i++) { var emp=json[i]; document.write(&quot;&lt;h1&gt;&quot;); document.write(emp.empno); document.write(&quot;,&quot;+emp.ename); document.write(&quot;,&quot;+emp.job); document.write(&quot;,&quot;+emp.hiredate); document.write(&quot;,&quot;+emp.salary); document.write(&quot;,&quot;+emp.dname); document.write(&quot;&lt;/h1&gt;&quot;); //访问嵌套的地方 if(emp.customers!=null){ document.write(&quot;&lt;h2&gt;---&quot;); for(var j=0;i&lt;emp.customers.length;j++) { var customer=emp.customers[j]; document.write(customer.cname); } document.write(&quot;&lt;/h2&gt;---&quot;); } } &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;JSON与字符串的互相转换字符串转json：JSON.parse(字符串名)； json转字符串:JSON.stringify(JSON名) 实例:string-&gt;json &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;字符串与JSON互相转换&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var str=&quot;{\&quot;class_name\&quot;:\&quot;五年级三班\&quot;}&quot;;//字符串 var json=JSON.parse(str); console.log(str); console.log(json); &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;json-&gt;string &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;字符串与JSON互相转换&lt;/title&gt; var json1={&quot;clssname&quot;:&quot;五年级四班&quot;}; var str1=JSON.stringify(json1); console.log(json1); console.log(str1); &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;json初始化可以看做成创建一个对象 var json2={}; json2.class_name=”五年级5班”; json2.foor=”四层”; json2.teacher=”王一凡”; console.log(json2); JSON与java的交互-java的JSON工具包还有FastJson,Jackson.Gson,Json-lib..-FastJson是阿里巴巴著名的JSON 序列化与反序列工具包-FastJson国内拥有大量的使用者,拥有Api简单,效率高等优点 JSON 逐渐替换了xml 成了保存传输的文件好工具 FastJSON的下载和安装:去github官网官网搜索fastjson :点 alibaba/fastjson,点Documentation下Documentation Home在下载和使用栏下下载最新版jar包下载后将其拖进eclipse工程下的WEB-INF下的lib文件夹中就可以使用了 FastJson对象序列化与反序列化和JSON注解1.类转换成字符串：String json= JSON.toJSONString(employee); 2.字符串转换成类:Employee emp=JSON.parseObject(json,Employee.class); JSON的注释： JSON注释对下一行代码生效@JSONField(format=”yyyy-MM-dd “)设置日期格式@JSONField(serialize=false)//不将其进行序列化 Employee类: package com.json; import java.util.Date; import com.alibaba.fastjson.annotation.JSONField; public class Employee { private Integer empno; private String name; private String job; @JSONField(format=&quot;yyyy-MM-dd &quot;) private Date hdate; private Float salary; @JSONField(serialize=false)//不对dname进行序列化 private String dname; public Integer getEmpno() { return empno; } public void setEmpno(Integer empno) { this.empno = empno; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getJob() { return job; } public void setJob(String job) { this.job = job; } public Date getHdate() { return hdate; } public void setHdate(Date hdate) { this.hdate = hdate; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } } import java.util.Calendar; import com.alibaba.fastjson.JSON; public class FastJson { public static void main(String[] args) { Employee employee= new Employee(); employee.setEmpno(4488); employee.setName(&quot;晓东&quot;); employee.setJob(&quot;客户经理&quot;); employee.setSalary(10000f); employee.setDname(&quot;市场部&quot;); Calendar c=Calendar.getInstance(); c.set(2019,0,30,0,0,0); employee.setHdate(c.getTime()); //FastJson中提供了JSON对象。完成对象与JSON字符串的相互转换 String json= JSON.toJSONString(employee); System.out.println(json); Employee emp=JSON.parseObject(json,Employee.class); System.out.println(emp.getName()); } } FastJSON对象数组序列化和反序列化实例:对象数组转为字符串:String json=JSON.toJSONString(emplist); 字符串再转回对象数组:List emps=JSON.parseArray(json,Employee.class); import java.util.ArrayList; import java.util.List; import com.alibaba.fastjson.JSON; public class FastJson2 { public static void main(String[] args) { List emplist= new ArrayList(); for(int i=0;i&lt;100;i++) { Employee employee=new Employee(); employee.setEmpno(4488+i); employee.setName(&quot;员工&quot;+i); emplist.add(employee); } String json=JSON.toJSONString(emplist); System.out.println(json); List&lt;Employee&gt; emps=JSON.parseArray(json,Employee.class); for(Employee e:emps) { System.out.println(e.getEmpno()+&quot;:&quot;+e.getName()); } } }]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexT的配置优化]]></title>
    <url>%2F2019%2F08%2F27%2FnexT%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[写在前面这是我的第一篇博客，我这个博客用的是用的比较广泛的nexT主题，所以想记录一下我对nexT简单基础配置 hexo最常用的命令 hexo s:启动本地服务器，用于预览主题,预览的同时可以修改文章内容或主题代码，保存后刷新页面即可,对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果hexo g:生成网站静态文件到默认设置的 public 文件夹。便于查看网站生成的静态文件或者手动部署网站； hexo d:自动生成网站静态文件，并部署到设定的仓库。hexo clean:清除缓存文件 db.json 和已生成的静态文件 public 。 ####### 每次修改后都要在博客所在文件夹右键 Git bush Here输入 hexo s 预览效果，如果效果合适，再输入hexo g hexo d 发布到设定的github仓库如果失败可以尝试 hexo clean 再进行重复操作 nexT配置优化1 启用主题打开所在博客所在文件夹的站点配置文件_config.yml,找到字段theme将theme后面改成，next（注意下载的next主题的文件名一定也是next否则theme后面写next不生效） 2 将next主题的文字改成中文我们进入博客所在文件夹-&gt;themes-&gt;next-&gt;lauguages我们可以发现这里面有好多YML文件，官方文档给的是中文改成zh-Hans.但是我当时改完之后发现好像变成了德语，后来查阅这个laguages文件才发现，简体中文对应的是zh-CN明确语言之后我们再次进入站点配置文件_config.yml 找到laguages字段 冒号后面写zh-CN 3 增加标签页和分类页 进入next里找到主题的配置文件，找到关键字menu 在menu下tags和categories前面的# 去掉]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>nexT</tag>
      </tags>
  </entry>
</search>

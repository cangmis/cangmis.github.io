<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AJAX项目-二级联动菜单的设置]]></title>
    <url>%2F2019%2F09%2F06%2FAJAX%E9%A1%B9%E7%9B%AE--%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8%E8%8F%9C%E5%8D%95%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[介绍二级联动的菜单在网页中很常见，通常是通过鼠标点一级菜单的相关内容之后二级菜单做出响应变化显示出一级菜单对应的子菜单。我这次是用AJAX的相关知识进行实现。 我的思路：1.首先我构造了一个类Channel目的就是为了为每个菜单添加名字和内容的两个属性。 2.在网页初初始化时候我们要对一级菜单进行显示，也就是向servlet中传递一个level=1的变量当服务器接收到level=1时 将一级菜单里面的内容通过json转为字符串传回到之前的html中通过javascript的AJax方法解析后，将内容放到对应html中的下拉表单中显示出来。 3.利用Ajax的动态更新，可以实时实现二级菜单的更新。因为每个一级菜单都对应一个二级菜单。所以在跟新二级菜单时候可以根据一级菜单每个菜单栏的名字去寻找。那么此时我们需要一个事件，也就是发生什么事件之后对二级菜单进行更新，这个事件就是鼠标点击事件，根据鼠标点击一级菜单的哪个菜单项获取对应的菜单项的属性名，传到服务器上，服务器可以根据这个属性名来判断传送这个一级菜单对应哪个二级菜单，判断后用json方法转为字符串传到html中。再根据AJax方法解析后，将内容放到对应html中的下拉表单中显示出来，从而动态显示二级菜单。 package com.ajax; public class Channel { private String name; private String code; public Channel() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public Channel(String name, String code) { super(); this.name = name; this.code = code; }}sevlet代码： import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class ChannelServlet */ @WebServlet(&quot;/channel&quot;) public class ChannelServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ChannelServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub String level=request.getParameter(&quot;level&quot;); String parent=request.getParameter(&quot;parent&quot;); List channelist= new ArrayList(); if(level.equals(&quot;1&quot;)) { channelist.add(new Channel(&quot;ai&quot;,&quot;前端/区块链/人工智能&quot;)); channelist.add(new Channel(&quot;web&quot;,&quot;前端/小程序/js&quot;)); } if(level.equals(&quot;2&quot;)) { if(parent.equals(&quot;ai&quot;)) { channelist.add(new Channel(&quot;micro&quot;,&quot;微服务&quot;)); channelist.add(new Channel(&quot;blocklist&quot;,&quot;区块链&quot;)); channelist.add(new Channel(&quot;other&quot;,&quot;。。。&quot;)); } else if (parent.equals(&quot;web&quot;)) { channelist.add(new Channel(&quot;html&quot;,&quot;HTML&quot;)); channelist.add(new Channel(&quot;css&quot;,&quot;CSS&quot;)); channelist.add(new Channel(&quot;other&quot;,&quot;。。。&quot;)); } } String json=JSON.toJSONString(channelist); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(json); } } &lt;!--html代码:--&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){//初始化显示一级菜单 $.ajax({ &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:{&quot;level&quot;:&quot;1&quot;}, &quot;dataType&quot;:&quot;json&quot;, &quot;type&quot;:&quot;get&quot;, &quot;success&quot;:function(json) { for(var i=0;i&lt;json.length;i++) { var ch=json[i]; $(&quot;#lv1&quot;).append(&quot;&lt;option value=&apos;&quot;+ch.name +&quot;&apos;&gt;&quot;+ch.code+&quot;&lt;/option&quot;); } } }) }) $(function(){//二级菜单 $(&quot;#lv1&quot;).click(function(){ var parent=$(this).val(); $.ajax({ &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:{&quot;level&quot;:&quot;2&quot;,&quot;parent&quot;:parent}, &quot;dataType&quot;:&quot;json&quot;, &quot;type&quot;:&quot;get&quot;, &quot;success&quot;:function(json) { $(&quot;#lv2&gt;option&quot;).remove(); for(var i=0;i&lt;json.length;i++) { var ch=json[i]; $(&quot;#lv2&quot;).append(&quot;&lt;option value=&apos;&quot;+ch.name +&quot;&apos;&gt;&quot;+ch.code+&quot;&lt;/option&quot;); } } }) }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;select id=&quot;lv1&quot; style=&quot;width:200px;height:30px&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;请选择&lt;/option&gt;//带有预先设置的下拉框 &lt;/select&gt; &lt;select id=&quot;lv2&quot; style=&quot;width:200px;height:30px&quot;&gt;&lt;/select&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX的入门学习]]></title>
    <url>%2F2019%2F09%2F06%2FAJAX%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[AJAX介绍 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 AJAX工作原理 AJAX的使用流程1.创建XMLHttpRequest对象 var xmlhttp; if(window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 var xmlhttp=new XMLHttpRequest; } else { // IE6, IE5 浏览器执行代码 var xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); }2.发送Ajax请求 xmlhttp.open(“GET”,”url”,”true); xmlhttp.send(); open(method,url,async):规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步） 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true； 同步执行：同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回这个期间客户端浏览器不能干任何事代码进入一个等待的时候，数据不返回时不会向下执行 异步执行：异步:请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕不会处于堵塞的 会一直向下执行，但是数据的返回时候触发onreadystatechange事件来完成注意：当使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可。 实际使用时 ajax推荐使用异步 实例： 服务器响应代码： import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class NewListServlet */ @WebServlet(&quot;/newslist&quot;) public class NewListServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public NewListServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub try { Thread.sleep(5000);//等待事件5000秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } List list=new ArrayList(); list.add(new News(&quot;TIOBE:2018年5月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年6月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年7月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年8月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年9月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); String json=JSON.toJSONString(list); System.out.println(json); response.setContentType(&quot;text/html ; charset=utf-8&quot;); response.getWriter().println(json); } }同步：var xmlhttp; if(window.XMLHttpRequest) { xmlhttp=new XMLHttpRequest(); } else { xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.open(&quot;GET&quot;,&quot;/ajax/newslist&quot;,false); xmlhttp.send(); console.log(&quot;请求发送完成&quot;); if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) { var t=xmlhttp.responseText; console.log(t); var json=JSON.parse(t); console.log(json); var html=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { var news=json[i]; html=html+&quot;&lt;h1&gt;&quot;+news.title+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;h2&gt;&quot;+news.date+&quot;&amp;nbsp;&quot;+news.source+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;hr/&gt;&quot;; } document.getElementById(&quot;container&quot;).innerHTML=html; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; xmlhttp.send();该程序会先等待当等待5000秒，5000秒后才输出请求发送完成和现显示响应内容。 异步：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var xmlhttp; if(window.XMLHttpRequest) { xmlhttp=new XMLHttpRequest(); } else { xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.open(&quot;GET&quot;,&quot;/ajax/newslist&quot;,true); xmlhttp.send(); console.log(&quot;请求发送完成&quot;); xmlhttp.onreadystatechange=function()//异步获取数据方法 { if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) { var t=xmlhttp.responseText; console.log(t); var json=JSON.parse(t); console.log(json); var html=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { var news=json[i]; html=html+&quot;&lt;h1&gt;&quot;+news.title+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;h2&gt;&quot;+news.date+&quot;&amp;nbsp;&quot;+news.source+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;hr/&gt;&quot;; } document.getElementById(&quot;container&quot;).innerHTML=html; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;执行完会立刻发送一个“请求发送完成字样 然后过5000秒后显示响应内容3.处理服务器的响应 xmlhttp.onreadystatechange()事件用于监听AJAX的执行过程 xmlhttp.readyState属性说明XMLHttpRequest当前状态 readyState=0 请求未初始化 readyState=1 服务器连接已建立 readyState=2 请求已经被接收 readyState=3 请求正在处理 readyState=4 相应文本已经接收 xmlhttp.status属性服务器响应状态码，200：成功。400没有找到。 xmlhttp.onreadystatechange=funcition(){ if(xmlhttp.readyState==4&amp;&amp;xml.status==200){ //获取相应体的文本var responseText=xmlhttp.responseText; } } jQuery对Ajax的支持 url:发送请求地址 type:请求类型get/post datatype:服务器响应的数据类型text|json|xml|html|jsonp|script data:向如武器传递的参数 success ：接收响应时的处理函数 error ：请求失败时处理的函数 async: 要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。 实例： import java.util.List; import java.io.IOException; import java.util.ArrayList; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class ZUOYE */ @WebServlet(&quot;/zuoye&quot;) public class ZUOYE extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ZUOYE() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub response.setContentType(&quot;text/html ; charset=utf-8&quot;); String tt=request.getParameter(&quot;t&quot;); List list=new ArrayList(); list.add(&quot;稻香&quot;); list.add(&quot;晴天&quot;); list.add(&quot;告白气球 &quot;); List list2=new ArrayList(); list2.add(&quot;千千阕歌&quot;); list2.add(&quot;傻女&quot;); list2.add(&quot;七友 &quot;); List list3=new ArrayList(); list3.add(&quot;一块红布&quot;); list3.add(&quot;假行僧&quot;); list3.add(&quot;新长征路上的摇滚 &quot;); int m=Integer.parseInt(tt); if(m==1) { String json=JSON.toJSONString(list); response.getWriter().println(json); } else if(m==2) { String json2=JSON.toJSONString(list2); response.getWriter().println(json2); } if(m==3) { String json3=JSON.toJSONString(list3); response.getWriter().println(json3); } } } ajax代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; input { width:33%; text-align:center; font-weight:bold;} div { margin-left:50%; width:100px; margin-top:200px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;b1&quot; value=&quot;流行歌曲&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;b2&quot; value=&quot;经典歌曲&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;b3&quot; value=&quot;摇滚歌曲&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;input[id=&apos;b1&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=1&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json) { console.log(json); var s=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); $(&quot;input[id=&apos;b2&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=2&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)//已经变成了json无需进行字符串的转化 { var s=&quot;&quot;; console.log(json); for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); $(&quot;input[id=&apos;b3&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=3&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)//已经变成了json无需进行字符串的转化 { console.log(json); var s=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;结果：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的入门学习]]></title>
    <url>%2F2019%2F09%2F05%2FJQuery%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[jQuery的介绍与下载安装 什么是jQuery jQuery是一个快速、简洁的JavaScript框架，它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。jQuery的核心特性可以总结为:具有独特的链式语法和短小清晰的多功能接口;具有高效灵活的css选择器，并且可对CSS选择器进行扩展;拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。 jQuery 下载 jQuery官网下载最新版本将下载好的jQuery放在WebContent里面 jQuery采用独立的JS文件发布 IDE:Eclipse，Hbuilder，sublime，webstorm jQuery基础语法 jQuery 选择器允 许您对 HTML 元素组或单个元素进行操作。jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”(或选择)HTML 元素。 它基于已经存在的CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头:$()。 文档就绪事件入口函数$(document).ready(function(){ // 开始写 jQuery 代码... });简写： $(function(){ // 开始写 jQuery 代码... });这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。如果在文档没有完全加载之前就运行函数，操作可能失败。 jQuery 入口函数与 JavaScript 入口函数的区别： jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行 基本选择器 1.$(“#id”)–ID选择器，指定Id元素对象 2.$(“标签”)–元素选择器，选择指定标签名的选择器 3.$(“.class”)–类选择器，选中拥有指定css类的元素 4.$(“S1,S2,S3”)组合选择器，对元素进行组合 层叠选择器$(“ancestor descendant”) 后代选择器 $(“ancestor&gt;descendant”)子选择器$(“prev ~ siblings”)兄弟选择器 后代选择器与子选择器最大的区别就是后代选择器可以选择该节点之后的所有节点而子选择器只能选择该节点的一个子节点。兄弟选择器是选择节点之后所有符合要求的平级节点 属性选择器 $(“selector[attribute=value]”)选中属性值等于具体值的组件 $(“selector[attribute^=value]”)选中属性值以某值开头的组件 $(“selector[attribute$=value]”)选中属性值以某值结尾的组件 $(“selector[attribute * =value]”)选中属性值包含某值的组件 位置选择器$(“selector:first”)获取第一个元素 $(“selector:last”)获取最后一个元素 $(“selector:even”)获取偶数的元素（从0开始） $(“selector:odd”)获取奇数位置的元素（从0开始） $(“selector:eq(n)”)获取指定位置的元素（从0开始） 表单选择器 $(“selector:input”)所有的输入元素 $(“selector:text”)所有的文本框 $(“selector:password”)获取密码框 $(“selector:submit”)获取提交按钮 $(“selector:reset) 获取重置按钮 操作元素的属性-attr(name|properties|key) 获取或者设置元素属性 -removeAttr(name) 移除元素属性 如果attr() 括号中有一个元素就是获取属性如果有两个就是更改属性 var href_attr=$(&quot;a[href*=&apos;163&apos;]&quot;).attr(&quot;href&quot;);//获取元素 alert(href_attr); $(&quot;a[href*=&apos;163&apos;]&quot;).attr(&quot;href&quot;,&quot;http://www.163.com&quot;);//更改元素 $(&quot;a&quot;).removeAttr(&quot;href&quot;);//移除属性，此时a标签不再有超链接属性操作元素的CSS属性 css()获取设置匹配元素样式属性 addClass() 为每个匹配的元素添加指定的类名 removeClass() 为所有匹配的元素中删除全部或者指定的类 $(&quot;a&quot;).css(&quot;color&quot;,&quot;red&quot;);//设置a标签中的文字是红色 var color=$(&quot;a&quot;).css(&quot;color&quot;);//获取a标签的颜色 alert(color); $(&quot;a&quot;).css({&quot;color&quot;:&quot;red&quot;,&quot;font-weight&quot;:&quot;bold&quot;,&quot;font-size&quot;:&quot;italic&quot;});//多个属性的设置 可以使用json表达式 $(&quot;li&quot;).addClass(&quot;highlight myclass&quot;);//添加类 $(&quot;p&quot;).removeClass(&quot;myclass&quot;);//移除类 设置元素内容-val() 获取或者设置输入项的值-text()获取或设置元素的纯文本-html() 获取或设置元素内容的HTML $(&quot;input[name=&apos;uname&apos;]&quot;).val(&quot;administrator&quot;);//设置 var s=$(&quot;input[name=&apos;uname&apos;]&quot;).val();//获取text与html中 最大的区别是对文本中的html标签是否进行转义一般用text方法对纯文本进行设置和获取 var ss=$(“span.myclass”).html(); var ss=$(“span.myclass”).text();//获得纯文本 一般用text方法对纯文本进行设置和获取 jQuery事件处理方法jQuery 事件方法语法在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。 页面中指定一个点击事件： $(&quot;p&quot;).click();下一步是定义什么时间触发事件。您可以通过一个事件函数实现： $(&quot;p&quot;).click(function(){ // 动作触发后执行的代码!! }); click()click() 方法是当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。 dblclick()当双击元素时，会发生 dblclick 事件。 mouseenter()当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseleave()当鼠标指针离开元素时，会发生 mouseleave 事件。mouseleave() 方法触发 mouseleave 事件， mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数 mouseup()当在元素上松开鼠标按钮时，会发生 mouseup 事件。mouseup() 方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数： hover()hover()方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 focus()当元素获得焦点时，发生 focus 事件。当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数： blur()当元素失去焦点时，发生 blur 事件。blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数： $(&quot;p.myclass&quot;).click(function(){ $(this).css(&quot;background-color&quot;,&quot;green&quot;);//此时myclass的背景色变为绿色 });jQuery效果- 隐藏和显示jQuery hide() 和 show() 通过 jQuery，您可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： $(&quot;#hide&quot;).click(function(){ $(&quot;p&quot;).hide(); }); $(&quot;#show&quot;).click(function(){ $(&quot;p&quot;).show(); });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON入门学习]]></title>
    <url>%2F2019%2F08%2F31%2FJSON%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[##什么是JSON 是一种轻量级的数据交换格式。他基于 javascript 语法的子集，即数组和对象表示。 采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率. 客户端向服务器端发送请求后，服务器端怎么才能把用户需要的数据返回给客户端呢。这时我们就需要用一个指定的格式将数据，按照指定格式返回客户端。这时就有了两种数据传输的方式（XML和Json),在普通的Web应用中，不管是服务器端还是客户端解析XML代码会非常麻烦，所以这时Json就更加满足数据传输解析的要求。采用Json格式的方式进行数据的传输，不仅方便传输解析，还特别易于人阅读和编写 JSON的语法规则 数据由键(key),值(value)描述,由逗号分隔 大括号代表一个完整的对象,又有多个键/值对 中括号保存数组,多个对象之间使用逗号分割 #####注意:key和value如果是字符串的时候一定要有引号 ###JSON实例利用JSON存储员工信 JSON: [ { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;李宁&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot; }, { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;张三&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot;, &quot;customers&quot;: [ { &quot;cname&quot;: &quot;李东&quot; }, { &quot;canme&quot;: &quot;王五&quot; } ] } ]可以用JSON来代替xmlxml&lt;student name=&quot;xiaoming&quot;&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;age&gt;26&lt;/age&gt; &lt;/student&gt; 替代后[{&quot;name&quot;:&quot;xiaoming&quot;,&quot;sex&quot;:&quot;female&quot;,&quot;age&quot;:&quot;26&quot;}]javascripe访问JSON对象JSON就相当于一个大数组,在javasripe中我们用访问数组的方式访问JSON就可以.一下是实例:&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; json是一个数组里面有各个对象的信息 var json= [ { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;李宁&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot; }, { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;张三&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot;, &quot;customers&quot;: [ { &quot;cname&quot;: &quot;李东&quot; }, { &quot;cname&quot;: &quot;王五&quot; } ] } ]; for(var i=0;i&lt;json.length;i++) { var emp=json[i]; document.write(&quot;&lt;h1&gt;&quot;); document.write(emp.empno); document.write(&quot;,&quot;+emp.ename); document.write(&quot;,&quot;+emp.job); document.write(&quot;,&quot;+emp.hiredate); document.write(&quot;,&quot;+emp.salary); document.write(&quot;,&quot;+emp.dname); document.write(&quot;&lt;/h1&gt;&quot;); //访问嵌套的地方 if(emp.customers!=null){ document.write(&quot;&lt;h2&gt;---&quot;); for(var j=0;i&lt;emp.customers.length;j++) { var customer=emp.customers[j]; document.write(customer.cname); } document.write(&quot;&lt;/h2&gt;---&quot;); } } &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;JSON与字符串的互相转换字符串转json：JSON.parse(字符串名)； json转字符串:JSON.stringify(JSON名) 实例:string-&gt;json &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;字符串与JSON互相转换&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var str=&quot;{\&quot;class_name\&quot;:\&quot;五年级三班\&quot;}&quot;;//字符串 var json=JSON.parse(str); console.log(str); console.log(json); &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;json-&gt;string &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;字符串与JSON互相转换&lt;/title&gt; var json1={&quot;clssname&quot;:&quot;五年级四班&quot;}; var str1=JSON.stringify(json1); console.log(json1); console.log(str1); &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;json初始化可以看做成创建一个对象 var json2={}; json2.class_name=”五年级5班”; json2.foor=”四层”; json2.teacher=”王一凡”; console.log(json2); JSON与java的交互-java的JSON工具包还有FastJson,Jackson.Gson,Json-lib..-FastJson是阿里巴巴著名的JSON 序列化与反序列工具包-FastJson国内拥有大量的使用者,拥有Api简单,效率高等优点 JSON 逐渐替换了xml 成了保存传输的文件好工具 FastJSON的下载和安装:去github官网官网搜索fastjson :点 alibaba/fastjson,点Documentation下Documentation Home在下载和使用栏下下载最新版jar包下载后将其拖进eclipse工程下的WEB-INF下的lib文件夹中就可以使用了 FastJson对象序列化与反序列化和JSON注解1.类转换成字符串：String json= JSON.toJSONString(employee); 2.字符串转换成类:Employee emp=JSON.parseObject(json,Employee.class); JSON的注释： JSON注释对下一行代码生效@JSONField(format=”yyyy-MM-dd “)设置日期格式@JSONField(serialize=false)//不将其进行序列化 Employee类: package com.json; import java.util.Date; import com.alibaba.fastjson.annotation.JSONField; public class Employee { private Integer empno; private String name; private String job; @JSONField(format=&quot;yyyy-MM-dd &quot;) private Date hdate; private Float salary; @JSONField(serialize=false)//不对dname进行序列化 private String dname; public Integer getEmpno() { return empno; } public void setEmpno(Integer empno) { this.empno = empno; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getJob() { return job; } public void setJob(String job) { this.job = job; } public Date getHdate() { return hdate; } public void setHdate(Date hdate) { this.hdate = hdate; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } } import java.util.Calendar; import com.alibaba.fastjson.JSON; public class FastJson { public static void main(String[] args) { Employee employee= new Employee(); employee.setEmpno(4488); employee.setName(&quot;晓东&quot;); employee.setJob(&quot;客户经理&quot;); employee.setSalary(10000f); employee.setDname(&quot;市场部&quot;); Calendar c=Calendar.getInstance(); c.set(2019,0,30,0,0,0); employee.setHdate(c.getTime()); //FastJson中提供了JSON对象。完成对象与JSON字符串的相互转换 String json= JSON.toJSONString(employee); System.out.println(json); Employee emp=JSON.parseObject(json,Employee.class); System.out.println(emp.getName()); } } FastJSON对象数组序列化和反序列化实例:对象数组转为字符串:String json=JSON.toJSONString(emplist); 字符串再转回对象数组:List emps=JSON.parseArray(json,Employee.class); import java.util.ArrayList; import java.util.List; import com.alibaba.fastjson.JSON; public class FastJson2 { public static void main(String[] args) { List emplist= new ArrayList(); for(int i=0;i&lt;100;i++) { Employee employee=new Employee(); employee.setEmpno(4488+i); employee.setName(&quot;员工&quot;+i); emplist.add(employee); } String json=JSON.toJSONString(emplist); System.out.println(json); List&lt;Employee&gt; emps=JSON.parseArray(json,Employee.class); for(Employee e:emps) { System.out.println(e.getEmpno()+&quot;:&quot;+e.getName()); } } }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JAVAWEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexT的配置优化]]></title>
    <url>%2F2019%2F08%2F27%2FnexT%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[写在前面这是我的第一篇博客，我这个博客用的是用的比较广泛的nexT主题，所以想记录一下我对nexT简单基础配置 hexo最常用的命令 hexo s:启动本地服务器，用于预览主题,预览的同时可以修改文章内容或主题代码，保存后刷新页面即可,对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果hexo g:生成网站静态文件到默认设置的 public 文件夹。便于查看网站生成的静态文件或者手动部署网站； hexo d:自动生成网站静态文件，并部署到设定的仓库。hexo clean:清除缓存文件 db.json 和已生成的静态文件 public 。 ####### 每次修改后都要在博客所在文件夹右键 Git bush Here输入 hexo s 预览效果，如果效果合适，再输入hexo g hexo d 发布到设定的github仓库如果失败可以尝试 hexo clean 再进行重复操作 nexT配置优化1 启用主题打开所在博客所在文件夹的站点配置文件_config.yml,找到字段theme将theme后面改成，next（注意下载的next主题的文件名一定也是next否则theme后面写next不生效） 2 将next主题的文字改成中文我们进入博客所在文件夹-&gt;themes-&gt;next-&gt;lauguages我们可以发现这里面有好多YML文件，官方文档给的是中文改成zh-Hans.但是我当时改完之后发现好像变成了德语，后来查阅这个laguages文件才发现，简体中文对应的是zh-CN明确语言之后我们再次进入站点配置文件_config.yml 找到laguages字段 冒号后面写zh-CN 3 增加标签页和分类页 进入next里找到主题的配置文件，找到关键字menu 在menu下tags和categories前面的# 去掉]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>nexT配置优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苍糜]]></title>
    <url>%2F2019%2F08%2F27%2F%E8%8B%8D%E7%B3%9C%2F</url>
    <content type="text"><![CDATA[这是 H1 列表1 列表2 a 子列表 b 子列表 列表3 ca 字体是斜线的 字体是加粗的 &lt;html&gt;&lt;/html&gt; 1234&lt;html&gt;&lt;/html&gt;&lt;html&gt;&lt;/html&gt;&lt;html&gt;&lt;/html&gt;&lt;html&gt;&lt;/html&gt; 引用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. hello hexoCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

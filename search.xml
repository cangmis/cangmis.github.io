<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven学习一]]></title>
    <url>%2F2019%2F11%2F12%2FMaven%E5%AD%A6%E4%B9%A0%E4%B8%80%EF%BC%88maven%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.什么是Maven Maven(翻译为”专家”，”内行”)是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。 2.Maven的核心特征 项目设置遵循统一的规则，保证不同开发环境的兼容性 强大的依赖管理，项目依赖组件自动下载，自动更新 依赖指的是jar包之间的相互依赖，比如我们搭建一个Struts2的开发框架时，光光有struts2-core-2.3.16.3.jar这个jar包是不行的，struts2-core-2.3.16.3.jar还依赖其它的jar包，依赖管理指的就是使用Maven来管理项目中使用到的jar包，Maven管理的方式就是“自动下载项目所需要的jar包，统一管理jar包之间的依赖关系”。 可扩展的插件机制，使用简单功能丰富 只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮我们处理其他事情 3.Maven 下载与环境配置3.1下载下载地址http://maven.apache.org/download.cgi解压缩安装包即可 Maven目录分析 bin：含有mvn运行的脚本 boot：含有plexus-classworlds类加载器框架 conf：含有settings.xml配置文件 lib：含有Maven运行时所需要的java类库 3.2设置环境变量首先要确保电脑上已经安装了JDK(要jdk 1.6+的版本) 然后再高级配置中的path目录下添加maven的bin目录下的地址 3.3检验是否安装成功在cmd中输入 mvn -v 如果显示如下类似信息，证明安装完成 C:\Users\888&gt;mvn -vApache Maven 3.6.2 (40f52333136460af0dc0d7232c0dc0bcf0d9e117; 2019-08-27T23:06:16+08:00)Maven home: E:\apache-maven-3.6.2\bin..Java version: 1.8.0_101, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk1.8.0_101\jreDefault locale: zh_CN, platform encoding: GBKOS name: “windows 10”, version: “10.0”, arch: “amd64”, family: “windows”]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven学习二]]></title>
    <url>%2F2019%2F11%2F12%2FMaven%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1.Maven项目的目录约定MavenProjectRoot(项目根目录) |—-src | |—-main | | |—-java ——存放项目的.java文件 | | |—-resources ——存放项目资源文件，如spring, hibernate配置文件 | |—-test | | |—-java ——存放所有测试.java文件，如JUnit测试类 | | |—-resources ——存放项目资源文件，如spring, hibernate配置文件 |—-target ——项目输出位置 |—-pom.xml —-用于标识该项目是一个Maven项目 2.用eclipse操作Maven 选择File -&gt; New -&gt;Project 在New窗口中选择 Maven -&gt; Maven Project 在new Maven Project窗口 根据项目的实际情况选择项目的存放目录，也可以选择【Use default Workspace location】默认工作空间 输入Group ID 和 Artifact ID 以及Package GroupId 一般是机构或者团体的英文，采用逆向域名的形式书写ArtifactId:项目名称说明用途Version 是版本号，一般采用版本＋单词的形式。例如1.0.0RELEASE. 3.Maven依赖管理 Maven利用dependency自动下载管理第三方jar 在pom.xml文件中配置项目依赖的第三方组件 maven自动将依赖从远程仓库下载到本地仓库（本地电脑中的某个目录），并在工程上使用。 4.maven的标准依赖配置&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;5.去哪里找这些jar包？5.1maven中央仓库的检索网站：检索链接：https://search.maven.org 需要什么jar包就去搜索。可直接复制该jar包的依赖拷贝到pom.xml的dependencies中。保存后便自动下载。在Maven Dependencies 中便可以查看该jar包。 5.2其他当有些程序需要的jar包不只是一个的时候maven就会对dependency进行深入解析将关联的jar包全部下载下来 6.本地仓库和中央仓库maven加载pom.xml时候查看依赖，maven先去本地仓库查找。（m2\repository)如果没有的话就去中央仓库进行下载 7.私服（提高下载速度）最出名的是阿里云的maven私服私服地址：https://maven.aliyun.com 复制服务器地址 https://maven.aliyun.com/repository/public 如果阿里云如果没有的话就去中央仓库进行下载这样可以显著的提高下载速度 添加代码 &lt;repositories&gt;--&gt;仓库的配置 &lt;repository&gt; &lt;!--创建私服的地址--&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;8.Maven打包 Maven可以将项目打包为jar或者war包 通过Plugins（插件）进行打包 Maven输出jar包的插件：maven-assembly-plugin9.插件使用 org.apache.maven.plugins maven-assembly-plugin 2.5.5 com.PinyinTestor jar-with-dependencies 10.打jar包 eclipse-&gt;运行旁边的下箭头-&gt;run configuration-&gt;Maven Build-&gt;new Configuration Name:说明作用的名字 base directory:此时的工程 Goals:assembly:assembly 前面是插件的名字后面是装配 当点击run时候,控制台如果显示Build Success则表示打包成功 生成的jar文件就被保存在target中 11.如何运行jar包在cmd中到指定jar包目录下 java -jar jar包名称]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven学习一]]></title>
    <url>%2F2019%2F11%2F12%2FMaven%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[1.Maven构建Web工程 选择File -&gt; New -&gt;Project 在New窗口中选择 Maven -&gt; Maven Project 在new Maven Project窗口 根据项目的实际情况选择项目的存放目录，也可以选择【Use default Workspace location】默认工作空间 输入Group ID 和 Artifact ID 以及Package 1.1修改jre在jre System Library默认指定1.5可以进行手动指定。右键-&gt;properties 更改jre版本(1.8)。 1.2修改jdk的编译级别工程名右键-&gt;property-&gt;java Compiler-&gt; Compiler compliance level（默认1.5）—-&gt;更改为1.8 ####1.3添加网页保存目录在main下添加webapp 2.怎么变成标准web项目项目右键-&gt;property-&gt;Project Facets-&gt;勾选Dynamic Web Module 选择3.1版本配置运行环境：点击Runtime 点击apacheTomcat点击配置项： context root： content directory：刚才创建的目录 3.web应用打包&lt;!--packaging代表输出的格式--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;bulid&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;3.1如何运行 eclipse-&gt;运行旁边的下箭头-&gt;run configuration-&gt;Maven Build-&gt;new Configuration Name:说明作用的名字 base directory:此时的工程 Goals:package 当点击run时候,控制台如果显示Build Success则表示打包成功 生成的war文件就被保存在target中 将该文件复制到tomat webapp目录下 在apache bin 目录下点击startup.bat 独立运行tomcat。 回到webapps中可以看见此war包的目录 直接在浏览器输入包名文件名就可运行 3.2如何自定义包名&lt;bulid&gt; &lt;finalName&gt;maven-web&lt;/finalName&gt; &lt;/build&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven学习四]]></title>
    <url>%2F2019%2F11%2F12%2FMaven%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[1.Maven常用命令 mvn archetype:generate 创建Maven工程结构 mvn compile 编译源代码 mvn test 执行测试用例 mvn clean 清除产生的项目 mvn package 项目打包 mvn install 安装到本地仓库 2.创建maven工程2.1小问题在cmd中执行mvn archetype:generate 时候发现程序卡在了 Generating project in Interactive mode 解决方法—&gt;加个参数 DarchetypeCatalog=internal 让它不要从远程服务器上取catalog: mvn archetype:generate -DarchetypeCatalog=internal 2.2怎么在eclipse导入maven工程new-&gt;import-&gt;Maven-Existing Maven projects-&gt;找到maven所在目录 3.maven工程编译*mvn compile * D:\maven&gt;mvn compile [INFO] Scanning for projects... [INFO] [INFO] -----------------------------&lt; com:maven &gt;------------------------------ [INFO] Building maven 1.0-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ maven --- [INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources. [INFO] skip non existing resourceDirectory D:\maven\src\main\resources [INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ maven --- [INFO] Nothing to compile - all classes are up to date [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 3.671 s [INFO] Finished at: 2019-11-12T21:20:37+08:00 [INFO] ------------------------------------------------------------------------ 编译成功，在maven 目录下多出一个target目录，target\classes里面存放的就是编译后的class文件， 4.maven工程测试mvn test [INFO] Scanning for projects... [INFO] [INFO] -----------------------------&lt; com:maven &gt;------------------------------ [INFO] Building maven 1.0-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ maven --- [INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources. [INFO] skip non existing resourceDirectory D:\maven\src\main\resources [INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ maven --- [INFO] Nothing to compile - all classes are up to date [INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ maven --- [INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources. [INFO] skip non existing resourceDirectory D:\maven\src\test\resources [INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ maven --- [INFO] Nothing to compile - all classes are up to date [INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ maven --- [INFO] Surefire report directory: D:\maven\target\surefire-reports ------------------------------------------------------- T E S T S ------------------------------------------------------- Running com.AppTest Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.032 sec Results : Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 11.446 s [INFO] Finished at: 2019-11-12T21:23:51+08:00 [INFO] 测试成功，在maven\target目录下会有一个test-classes目录，存放的就是测试代码的class文件. 4.maven工程打包------------------------------------------------------- T E S T S ------------------------------------------------------- Running com.AppTest Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.032 sec Results : Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ maven --- [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 10.676 s [INFO] Finished at: 2019-11-12T21:46:58+08:00 [INFO] ------------------------------------------------------------------------###5.maven安装到本地仓库mvn install 执行安装命令前，会先执行编译、测试、打包命令， 构建成功，就会将项目的jar包安装到本地仓库 6.修改本地仓库地址修改maven中的conf中的settings.xml文件 默认是用户区/.m2/repository下修改：e:maven-repo ###7.在IDE中如何生效window-&gt;preferences-&gt;Maven-&gt;Installation一定指向自己安装maven的目录UserSetting-&gt;User settings指向核心配置文件也就是刚创建的setting.xml中local Repository：中的目录地址自动更新就是新创建的本地仓库的地址 为了减少下载时间。可以把原来仓库的jar包复制到新的本地仓库中。每当运行时候maven先检查本地仓库有没有，如果没有就去中央仓库去下载 8.在idea中更改仓库地址settings-&gt;build execution-&gt;Maven 更改Maven home directory 选择已经下载的maven版本 User settings file: 选择settings.xmlLocal repository:自动更新]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java表达式语言]]></title>
    <url>%2F2019%2F10%2F23%2FJava%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80EL%2F</url>
    <content type="text"><![CDATA[1.ELEL（Expression Language） 是为了使JSP写起来更加简单。功能：在页面上显示数据。 2.语法${表达式} 3.作用域对象EL表达式内置四种作用域对象忽略书写作用域对象时，EL则按作用域从小到大依次尝试获取 pageScope—从当前页面取值 requestScope—从当前请求中获取属性值 sessionScope—-从当前会话中获取属性值 applicationScope—-从当前应用获取全局属性值 4.表达式输出 ${title} ${requestScope.student.name} ${emp.salary+30} ${1&lt;=3&amp;&amp;2&gt;4}5. EL输出参数值 EL表达式内置param对象来简化参数的输出${param.参数名}${param.name} 等价于request.getParamter(“name”)，]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>JSP_EL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准标签库JSTL]]></title>
    <url>%2F2019%2F10%2F23%2F%E6%A0%87%E5%87%86%E6%A0%87%E7%AD%BE%E5%BA%93JSTL%2F</url>
    <content type="text"><![CDATA[1.JSTL是什么 JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。 JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。 2.JSTL库的安装1.从Apache的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)2.下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，3.将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下。 3.核心标签核心标签是最常用的 JSTL标签。引用核心标签库的语法如下： &lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; 在java或者jsp文件中输入Alt+/可出现智能提示&lt;%@ taglib uri=”ALT+/“ prefix=”c”%&gt; 3.1判断标签 &lt;c:if&gt;与我们在一般程序中用的if一样 实例： protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub request.setAttribute(&quot;score&quot;, 78); request.setAttribute(&quot;grade&quot;, &quot;B&quot;); request.getRequestDispatcher(&quot;/core.jsp&quot;).forward(request, response); ${requestScope.score} &lt;c:if test=&quot;${score&gt;=60 }&quot;&gt; &lt;/h1 style=&quot;color:green&quot;&gt;通过&lt;/h1&gt; &lt;/c:if&gt; &lt;c:if test=&quot;${score&lt;60 }&quot;&gt; &lt;/h2 style=&quot;color:red&quot;&gt;抱歉&lt;/h2&gt; &lt;/c:if&gt; &lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt; &lt;c:choose&gt;标签没有属性。 &lt;c:when&gt;标签只有一个属性，在下表中有给出。 &lt;c:otherwise&gt;标签没有属性。 实例 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;c:choose 标签实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;c:set var=&quot;salary&quot; scope=&quot;session&quot; value=&quot;${2000*2}&quot;/&gt; &lt;p&gt;你的工资为 : &lt;c:out value=&quot;${salary}&quot;/&gt;&lt;/p&gt; &lt;c:choose&gt; &lt;c:when test=&quot;${salary &lt;= 0}&quot;&gt; 太惨了。 &lt;/c:when&gt; &lt;c:when test=&quot;${salary &gt; 1000}&quot;&gt; 不错的薪水，还能生活。 &lt;/c:when&gt; &lt;c:otherwise&gt; 什么都没有。 &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/body&gt; &lt;/html&gt;3.2遍历集合&lt;c:forEach&gt;标签有如下属性： items 要被循环的信息 var 代表当前条目的变量名称 varStatus 代表循环状态的变量名称 begin 开始的元素（0=第一个元素，1=第二个元素） end 最后一个元素（0=第一个元素，1=第二个元素） step 每一次迭代的步长 实例： &lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;5&quot;&gt; Item &lt;c:out value=&quot;${i}&quot;/&gt;&lt;p&gt;结果Item 1Item 2Item 3Item 4Item 5 List list=new ArrayList(); list.add(new Company(&quot;腾讯&quot;,&quot;www.tencent.com&quot;)); list.add(new Company(&quot;百度&quot;,&quot;www.baidu.com&quot;)); list.add(new Company(&quot;慕课网&quot;,&quot;www.imooc.com&quot;)); request.setAttribute(&quot;companies&quot;,list); request.getRequestDispatcher(&quot;/core.jsp&quot;).forward(request, response);core.jsp &lt;c:forEach items=&quot;${requestScope.companies}&quot; var = &quot;c&quot; varStatus=&quot;idx&quot;&gt; &lt;h2&gt;${idx.index+1}.${c.name}-${c.url}&lt;/h2&gt; &lt;!-- index 循环索引 --&gt; &lt;/c:forEach&gt;4.格式化标签 &lt;%@ taglib prefix=”fmt” uri=”http://java.sun.com/jsp/jstl/fmt&quot; %&gt; 格式化日期标签: &lt;fmt:formatDate value=”” pattern=””/&gt; 格式化数字&lt;fmt:formatNumber value=”” pattern=””/&gt; &lt;% request.setAttribute(&quot;amt&quot;,1984755.55); request.setAttribute(&quot;html&quot;,&quot;&lt;a href=&apos;index.html&apos;&gt;index&lt;/a&gt;&quot;); request.setAttribute(&quot;now&quot;,new java.util.Date()); request.setAttribute(&quot;Nothing&quot;, null); %&gt; &lt;fmt:formatDate value=&quot;${requestScope.now }&quot; pattern=&quot;yyyy年 MM月 dd日 HH时 mm分 ss秒 SSS毫秒&quot;/&gt; &lt;fmt:formatNumber value=&quot;${amt}&quot; pattern=&quot;0.00&quot;/&gt; &lt;fmt:formatNumber value=&quot;${amt}&quot; pattern=&quot;0,00,00&quot;/&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>JSP_JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP入门]]></title>
    <url>%2F2019%2F10%2F23%2FJSP%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.什么是JSP JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。 JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。 JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。 JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。 2.JSP的运行要求 可正常运行的tomcat 所有的JSP页面扩展名必须是.jsp JSP页面应放在Web应用程序目录下 3.JSP执行过程 jsp经过转译为Servlet源代码再经过编译为Servlet字节码 4.JSP语法脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。 脚本程序的语法格式： &lt;% 代码片段 %&gt; 4.1中文编码问题 如果我们要在页面正常显示中文，我们需要在 JSP 文件头部添加以下代码： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;4.2JSP声明 &lt;%! declaration; [ declaration; ]+ … %&gt; 4.3JSP表达式 一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。 由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。 表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。 &lt;%= 表达式 %&gt; 4.4 JSP注释 &lt;%– 该部分注释在网页中不会被显示–%&gt; 4.5 JSP指令 &lt;%@ page … %&gt;：定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 &lt;%@ include … %&gt;:包含其他文件 &lt;%@ taglib … %&gt;：引入标签库的定义，可以是自定义标签 4.6JSP九大隐含对象 request–HttpServletRequest类的实例 response–HttpServletResponse类的实例 out–PrintWriter类的实例，用于把结果输出至网页上 session–HttpSession类的实例 application–ServletContext类的实例，与应用上下文有关 config–ServletConfig类的实例 pageContext–PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 page–类似于Java类中的this关键字 Exception–Exception类的对象，代表发生错误的JSP页面中对应的异常对象]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC入门]]></title>
    <url>%2F2019%2F10%2F22%2FJDBC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.什么是JDBC JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。 2. JDBC API 2.1DriverManager 2.1.1.注册驱动 有两种注册驱动的方式 - DriverManager.registerDriver(new Driver()); - Class.forName(“com.mysql.cj.jdbc.Driver”); *一般用后一种，因为前一种的方法会导致驱动注册两次&lt;br&gt;*2.1.2 获得连接Connection conn = DriverManager.getConnection(String url,String name,String password);url写法：jdbc:mysql://localhost:3306/jdbcjdbc:协议mysql:子协议3306：端口号 2.2Connection:连接对象2.2.1创建SQL语句的对象 Statement createStatement():执行SQL语句，有SQL注入的漏洞的存在 PreparedSteatement prepareStatement(String) :预编译Sql语句。解决SQL注入的漏洞 2.3.Statement：执行SQL 2.3.1 执行SQL语句boolean execute(String sql):执行SQL，执行select语句返回true 否则返回falseResultSet executeQuery(String sql):执行SQL中的select语句int executeUpdate(String sql)：执行更新语句 2.4 ResultSet：结果集结果集：就是查询语句中查询结果的封装next()针对不同的雷响的数据可以使用getXXX()来获取数据，通用的获取数据的方法是getObject()。 3.JDBC 入门编写步骤 搭建开发环境 需要的jar包有：junit和mysql-connector 编写程序，在程序中加载数据库的驱动 建立连接 创建sql色执行对象 从代表结果集的ResultSet中取出数据 断开与数据库的连接，并且释放相资源 4.数据库的资源释放一般要释放的资源是Connection对象和Statement对象会ResultSet对象.特别是Connection对象。它是很稀有的资源，用完必须释放。如果不及时，正确的关闭，会导致系统宕机。Connection的使用原则是晚创建早释放。资源释放代码要放在finally语句中 finally { //释放资源 if(rs!=null) { try { rs.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } rs=null; } if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } stmt=null; } if(conn!=null) { try { conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } conn=null; } }4 实例4.1数据库的更新 public void demo1() { Connection conn=null; Statement stmt=null; try { //注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //创建连接 conn=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC&quot;,&quot;root&quot;,&quot;****&quot;); //获得执行Sql语句的对象； stmt=conn.createStatement(); String sql=&quot;insert into goods values(null,&apos;耳机&apos;,200.0,&apos;蓝牙耳机&apos;)&quot;; int i=stmt.executeUpdate(sql); if(i&gt;0) System.out.println(&quot;保存成功&quot;); }catch(Exception e) { e.printStackTrace(); } finally { //释放资源 if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } stmt=null; } if(conn!=null) { try { conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } conn=null; } } }4.2数据库的查询 public void demo6() { Connection conn=null; Statement stmt=null; ResultSet rs=null; try { //注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //获取连接 conn=DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC&quot;,&quot;root&quot;,&quot;****&quot;); //获得执行Sql语句的对象； stmt=conn.createStatement(); String sql=&quot;select * from user where uid=2&quot;; rs =stmt.executeQuery(sql); while(rs.next()) { System.out.println(rs.getInt(&quot;uid&quot;)+&quot; &quot;+rs.getString(&quot;username&quot;)+&quot; &quot;+rs.getString(&quot;name&quot;)); } }catch(Exception e) { e.printStackTrace(); } finally { //释放资源 if(rs!=null) { try { rs.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } rs=null; } if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } stmt=null; } if(conn!=null) { try { conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } conn=null; } } } 5.JDBC工具类的提取加载驱动，获取连接，资源释放这些代码都是基本相同，所以可以提取变成一个工具类方便使用同时像这种driverClass，url可以在资源文件中提前定义。在工具类中进行提取。如果日后有更改直接修改资源文件中即可。 public class utils { private static final String driverClass; private static final String url; private static final String username; private static final String password; static { //加载属性文件并解析 Properties props=new Properties(); //如何让获得属性文件的输入流？ //通常能情况下使用类Properties props的加载器的方式进行获取 InputStream is=utils.class.getClassLoader().getResourceAsStream( &quot;jdbc.properties&quot;); try { props.load(is); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } driverClass=props.getProperty(&quot;driverClass&quot;); url=props.getProperty(&quot;url&quot;); username=props.getProperty(&quot;username&quot;); password=props.getProperty(&quot;password&quot;); } /** * * @throws ClassNotFoundException */ public static void loadDriver() throws ClassNotFoundException { Class.forName(driverClass); } /** * 获得连接的方法: * @throws SQLException * */ public static Connection getConnection() throws Exception {loadDriver(); Connection conn=DriverManager.getConnection(url,username,password); return conn; } /** * 资源释放 * */ public static void release(Statement stmt,Connection conn) { if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } stmt=null; } if(conn!=null) { try { conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } conn=null; } } public static void release(ResultSet rs,Statement stmt,Connection conn) { if(rs!=null) { try { rs.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } rs=null; } if(stmt!=null) { try { stmt.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } stmt=null; } if(conn!=null) { try { conn.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } conn=null; } } }properties: driverClass=com.mysql.cj.jdbc.Driver jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC username=root password=****6.SQL注入漏洞 6.1 什情况下会出现漏洞如果知道用户名就可对其破坏当把参数(“aaa’or ‘1=1”,”asdikjaljdkfjdkfj”)传到public static boolean login(String username,String password)中.在创建sql语句时候String sql=”select * from user where username =’”+username+”‘and password=’”+password+”‘“; sql=select * from user where username=&apos;aaa&apos; or &apos;1=1&apos;and username=&apos;asdikjaljdkfjdkfj&apos;&lt;br&gt;计算时候先计算and 答案是false 在or一个正确的用户名答案是true。 6.2解决方法PaparedStatement是Statement的子接口，它的实例对象可以通过调用Connection.preparedStatement(sql)方法获得。 PaparedStatement避免的SQL漏洞注入的问题 Statement会使数据库更频繁的编译SQL ，可能造成数据库缓冲区的溢出 PaparedStatement对SQL进行预编译，从而提高数据的执行效率 并且PaparedStatement对于sql的餐是允许使用占位符的形式进行替换，简化sql语句的编写 使用方式： public void demo1() { Connection conn=null; PreparedStatement pstmt=null; try { //工具类进行连接 conn=utils.getConnection(); //书写sql语句 String sql=&quot;insert into user values(null,?,?,?)&quot; //预编译 pstmt=conn.prepareStatement(sql); //赋值 pstmt.setString(1,&quot;qq&quot;);//数字1代表第一个&apos;？&apos; pstmt.setString(2,&quot;123&quot;); pstmt.setString(3, &quot;zhangwu&quot;); //执行 int num=pstmt.executeUpdate(); if(num&gt;0) System.out.println(&quot;保存成功&quot;); }catch(Exception e) { e.printStackTrace(); } finally { utils.release(pstmt,conn); } } }7.csp0连接池的使用7.1在这之前连接数据库出现的问题 获取数据库连接需要消耗比较多的资源, 而每次操作都要重新获取新的连接对象, 执行一次操作就把连接关闭, 而数据库创建连接通常需要消耗相对较多的资源, 创建时间也比较长, 这样数据库连接对象的使用率低 假设网站一天10万的访问量, 数据库服务器就需要创建10万次连接, 极大的浪费数据库资源, 并且极易造成数据库服务器内存溢出 7.2连接池原理 程序一开始就创建一定数量的连接, 放在一个容器中, 这个容器称为连接池 也叫数据源 DataSource 使用的时候直接从连接池中取一个已经创建好的连接对象 关闭的时候不是真正的关闭连接, 而是将连接对象再次放回到连接池中 7.3 相关jar包 mysql驱动包：mysql-connector-….jar c3p0依赖包：c3p0-0.9.5.2.jar 7.4 c3p0配置文件： c3p0-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///jdbctest&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;abc&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt;&lt;/default-config&gt; &lt;/c3p0-config&gt;7.5实体类 package com.imooc.jdbc.demo3; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import org.junit.Test; import com.imooc.jdbc.utils.JDBCUtils; import com.imooc.jdbc.utils.JDBCUtils2; import com.mchange.v2.c3p0.ComboPooledDataSource; /** * 连接池的测试类 * @author jt * */ public class DataSourceDemo1 { @Test /** * 使用配置文件的方式 */ public void demo2(){ Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try{ /*// 获得连接: ComboPooledDataSource dataSource = new ComboPooledDataSource();*/ // 获得连接: // conn = dataSource.getConnection(); conn = JDBCUtils2.getConnection(); // 编写Sql: String sql = &quot;select * from user&quot;; // 预编译SQL: pstmt = conn.prepareStatement(sql); // 设置参数 // 执行SQL: rs = pstmt.executeQuery(); while(rs.next()){ System.out.println(rs.getInt(&quot;uid&quot;)+&quot; &quot;+rs.getString(&quot;username&quot;)+&quot; &quot;+rs.getString(&quot;password&quot;)+&quot; &quot;+rs.getString(&quot;name&quot;)); } }catch(Exception e){ e.printStackTrace(); }finally{ JDBCUtils2.release(rs, pstmt, conn); } } @Test /** * 手动设置连接池 */ public void demo1(){ // 获得连接: Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try{ // 创建连接池: ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 设置连接池的参数: dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql:///jdbctest&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;abc&quot;); dataSource.setMaxPoolSize(20); dataSource.setInitialPoolSize(3); // 获得连接: conn = dataSource.getConnection(); // 编写Sql: String sql = &quot;select * from user&quot;; // 预编译SQL: pstmt = conn.prepareStatement(sql); // 设置参数 // 执行SQL: rs = pstmt.executeQuery(); while(rs.next()){ System.out.println(rs.getInt(&quot;uid&quot;)+&quot; &quot;+rs.getString(&quot;username&quot;)+&quot; &quot;+rs.getString(&quot;password&quot;)+&quot; &quot;+rs.getString(&quot;name&quot;)); } }catch(Exception e){ e.printStackTrace(); }finally{ JDBCUtils.release(rs, pstmt, conn); } } }7.6 常见配置参数 initialPoolSize：初始连接数 maxPoolSize：最大连接数 checkoutTimeout：最大等待时间 maxIdleTime：最大空闲回收时间 7.7 注意1、程序默认读取src目录下c3p0-config.xml2、数据源默认使用标签下的连接3、使用完毕释放资源]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天小张leetcode了吗]]></title>
    <url>%2F2019%2F10%2F19%2Fleetcode-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目划分字母区间 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例 1:输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8] 解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 注意:S的长度在[1, 500]之间。S只包含小写字母’a’到’z’。 思路首先设定字符串的开头字符索引值为start。利用lastIndexOf函数从右向左寻找到第一次出现该字符的索引值设为border。然后遍历从start到border中间所有的值，如果其中有某些字符的border值大于已定的border值就更新border。直到遍历完所有start到border的字符。此时划分的一个字母区间产生，将字母区间的长度添加到list列表中。更新start为上一次确定的border索引值的下一个数。重复刚才的遍历过程。直到start的值大于字符串的长度。也就是说此时已经遍历完整个字符串。退出循环。 代码class Solution { public List&lt;Integer&gt; partitionLabels(String s) { List&lt;Integer&gt;number=new ArrayList&lt;&gt;(); char [] a=s.toCharArray(); int start=0; int border=s.lastIndexOf(a[start]); while(true) { for(int i=start;i&lt;=border;i++) { if(s.lastIndexOf(a[i])&gt;border) { border=s.lastIndexOf(a[i]); } } int len=border-start+1; number.add(len); start=border+1; if(start==s.length()) { break; } border=s.lastIndexOf(a[start]); } return number; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL函数操作]]></title>
    <url>%2F2019%2F10%2F16%2FMySQL%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.数学函数 CHAR_LENGTH():得到字符串的字符数 SELECT CHAR_LENGTH(‘abc’); LENGTH():返回字符串的长度 SELECT LENGTH(‘abc’); CONCAT(s1,s2,….):将字符串合并成一个字符串 SELECT CONCAT(‘a’,’b’,’c’); 如果字符串中包含NULL，返回拼接结果就是NULL SELECT CONCAT(‘a’,’b’,’c’,null); CONCAT_WS(x,s1,s2,s2….)：以指定分隔符拼接字符串 SELECT CONCAT_WS(‘-‘,’a’,’b’,’c’);a-b-c SELECT CONCAT_WS(‘-‘,’a’,’b’,’c’,null); 如果分隔符为null，拼 接的结果为null 将字符串转换成大写或者小写 UPPER()| UCASE() LOWER()|LCASE() SELECT UPPER(‘hello king’),UCASE(‘hello imooc’),LOWER(‘HELLO ADMIN’),LCASE(‘HELLO EVERYBODY’); 字符串的反转REVERSE() SELECT REVERSE(‘abc’); LEFT()|RIGHT():返回字符串的前几个字符或者后几个字符 SELECT LEFT(‘hello’,2),RIGHT(‘hello’,2); LPAD()|RPAD():用字符串填充到指定长度 SELECT LPAD(‘abc’,10,’?’);SELECT RPAD(‘abc’,10,’!’); 去掉字符串两端的空格TRIM()|LTRIM()|RTRIM():(中间，左边，右边) SELECT CONCAT(‘‘,TRIM(‘ abc ‘),’‘),CONCAT(‘‘,LTRIM(‘ abc ‘),’‘),CONCAT(‘‘,RTRIM(‘ abc ‘),’‘); REPEAT():重复指定的次数 SELECT REPEAT(‘hello’,3); REPLACE():字符串替换 SELECT REPLACE(‘hello king’,’king’,’queen’); 截取字符串SUBSTRING SELECT SUBSTRING(‘abcdef’,1,3); 比较字符串 SELECT STRCMP(‘a’,’b’);a==b return 0a&gt;b return 1a&lt;b return -1 2.日期函数 返回当前日期 SELECT CURDATE(),CURRENT_DATE(); 返回当前时间 SELECT CURTIME(),CURRENT_TIME(); 返回当前的日期时间 SELECT NOW(),CURRENT_TIMESTAMP(),SYSDATE(); 返回日期中的月份和月份的名称 SELECT MONTH(‘2017-02-19’);SELECT MONTH(CURDATE()),MONTHNAME(CURDATE()); 返回星期几 SELECT DAYNAME(NOW()); 返回一周内的第几天,0代表星期一 SELECT DAYOFWEEK(NOW());SELECT WEEK(NOW()); SELECT YEAR(NOW()),MONTH(NOW()),DAY(NOW()),HOUR(NOW()),MINUTE(NOW()),SECOND(NOW()); DATEDIFF()计算两个日期相差的天数 SELECT DATEDIFF(‘2017-03-06’,’2017-03-02’);4 3.其它常用函数 SELECT VERSION(),CONNECTION_ID(); SELECT USER(),CURRENT_USER(),SYSTEM_USER(),SESSION_USER(); 得到上一步插入操作产生AUTO_INCREMENT的值 SELECT LAST_INSERT_ID(); SELECT MD5(‘king’); PASSWORD():密码加密算法 SELECT PASSWORD(‘root’);]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F10%2F16%2Fleetcode-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[题目最后一块石头 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0 思路题目标签给的贪心，我并没有用贪心。 题目意思就是每次选这堆石头中最重的两块取出来。如果相等就把这两块石头都粉碎。如果不等就粉碎小的那个。大的那个变成两块石头的差值重量。 那么我想的就是用list去存放所有的石头的重量。先用器的排列函数Collections.sort(list)对所有石头的重量进行排序。 然后挑选最大和倒数第二大的石头进行粉碎操作。因为list.remove();可以删除指定位置的石头重量。就相当于是石头粉碎从列表中去除。 list.add()将x！=y情况下得重量差值添加到列表中。 因为list.move()函数在删除的时候，前面的元素删除后面的元素依次向前移动。所以在同时删除两个石头的重量值得情况下，一定要先删除后一个。在删除前一个。 再次利用容器的排列函数。 Collections.sort(list) 实现每次粉碎之后的剩余列表的排序。 代码class Solution { public int lastStoneWeight(int[] stones) { List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); for(int i=0;i&lt;stones.length;i++) { list.add(stones[i]); } Collections.sort(list); while(true) { Collections.sort(list); int len=list.size(); if(len==0)//没有石头了直接返回0 { return 0; } if(len==1)//只剩一个石头退出循环 { break; } if(list.get(len-1).equals(list.get(len-2)))//最大一个和第二大的进行比较x==y { list.remove(len-1); list.remove(len-2); } else//x！=y { int num=list.get(len-1)-list.get(len-2); list.remove(len-1); list.remove(len-2); list.add(num);//添加差值 } } return list.get(0);//返回列表中仅剩的一个 } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode--</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF刷题]]></title>
    <url>%2F2019%2F10%2F16%2FCCF--%E5%B0%8F%E4%B8%AD%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[思路这道题为简单题。但是值的注意的是: 一定要确定中位数是整数还是小数 是整数就直接输出 是小数就要四舍五入保留一位小数输出 ###JAVA中四舍五入的方法总结: String format = new DecimalFormat(“#.0000”).format(3.1415926);System.out.println(format);(3.1416) double num = 3.1415926;String result = String.format(“%.4f”, num);System.out.println(result);(3.1416) 代码 package test; import java.text.DecimalFormat; import java.util.Scanner; public class c { public static void main(String[] args) { Scanner in=new Scanner(System.in); int min=0; int max=0; while(in.hasNext()) { int n= in.nextInt(); int a[]=new int[n]; for(int i=0;i&lt;a.length;i++) { a[i]=in.nextInt(); } if(a[0]&gt;a[n-1])//判断该序列是从小到大排序还是从大到小排序 { min=a[n-1]; max=a[0]; } else { min=a[0]; max=a[n-1]; } double zw=0; int zw1=0; int flag=0; String result=&quot;&quot;; if(n%2==0) { if((a[n/2]+a[n/2-1])%2==0)//判断能否整除，如果整除就用int类型变量保存。 { zw1=(a[n/2]+a[n/2-1])/2; } else { zw=(a[n/2]+a[n/2-1])/2.0; result = new DecimalFormat(&quot;#.0&quot;).format(zw);//四舍五入保留一位小数 flag=1; } } else { zw1=a[n/2]; } if(flag==1) { if(zw&gt;min) {System.out.print(max+&quot; &quot;+result+&quot; &quot;+min); } else { System.out.print(max+&quot; &quot;+min+&quot; &quot;+result); } } else { if(zw1&gt;min) System.out.println(max+&quot; &quot;+zw1+&quot; &quot;+min); else System.out.println(max+&quot; &quot;+min+&quot; &quot;+zw1); } } }}]]></content>
      <categories>
        <category>CCF</category>
      </categories>
      <tags>
        <tag>-CCF_小中大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F10%2F15%2F%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[题目 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例 1： 输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。示例 2： 输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 思路不管输入的数字是什么。只要占到2就赢。占到1就输偶数的因子是偶数或者奇数。而奇数的因子一定是奇数如果输入的数字是偶数。那么只要爱丽丝一直占偶数,把奇数给鲍勃，那么爱丽丝一定可以占到最后的最小偶数2，而最后的1属于鲍勃。鲍勃没得选择，因此爱丽丝赢。 为了保证奇数留给鲍勃同时保证偶数可以除开。那么爱丽丝只需要每局选1即可。又因为奇数-奇数=偶数。所以爱丽丝可以始终占偶数。 如果输入的数是奇数的话。爱丽丝只能选奇数作为该局的选择。那么奇数-奇数等于偶数。那么鲍勃则占了偶数。鲍勃只需要每轮都占偶数。把奇数留给爱丽丝。鲍勃赢。爱丽丝输. 代码class Solution { public boolean divisorGame(int N) { if(N%2==0) { return true; } else { return false; } } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode--博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F10%2F15%2F%E8%B4%AA%E5%BF%83-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。 返回尽可能高的分数。 示例： 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]输出：39解释：转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 提示： 1 &lt;= A.length &lt;= 201 &lt;= A[0].length &lt;= 20A[i][j] 是 0 或 1 思路0b1000&gt;0b0111 因此第一位为1很关键。所以我们首先要把每一行的第一列通过行变换设为1. 然后我发现如果求总体数额最大的话就要尽可能的让每位为1. 所以我们就要观察竖列。如果每列的0比1多就要进行翻转使得1比0多。这样可以尽可能多的保证更多的位值为1. 代码class Solution { public int matrixScore(int[][] a) { for(int i=0;i&lt;a.length;i++)//让首列为1 { if(a[i][0]!=1) { for(int j=0;j&lt;a[0].length;j++) { if(a[i][j]==1) a[i][j]=0; else a[i][j]=1; } } } int count1=0; int count0=0; for(int j=1;j&lt;a[0].length;j++) { count1=0;//记录0的数目 count0=1;//记录1的数目 for(int i=0;i&lt;a.length;i++) { if(a[i][j]==1) { count1++; } else { count0++; } } if(count1&lt;count0)//如果1的数目小于0的数目就翻转 { for(int k=0;k&lt;a.length;k++) { if(a[k][j]==1) a[k][j]=0; else a[k][j]=1; } } } int p=1; int sum=0; int ans=0; for(int i=0;i&lt;a.length;i++)//变成10进制 { p=1; sum=0; for(int j=a[0].length-1;j&gt;=0;j--) { sum+=a[i][j]*p; p=p*2; } ans+=sum; } return ans; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode--贪心</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F15%2F%E8%B4%AA%E5%BF%83--%E7%8E%A9%E7%AD%B9%E7%A0%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础之数据类型]]></title>
    <url>%2F2019%2F10%2F09%2FMySQL%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.什么是数据库 数据库是按照数据结构来组合，存储和管理数据的仓库 1.1常见数据库 Oracle DB2 SQL Server Postgre SQL MySQL1.2相关术语 数据库系统DBS 数据库 数据库管理系统 应用开发工具 管理员及用户 SQL语言Structured Query Language：结构化查询语言 DDL 数据定义语言 DML 数据操作语言 DQL 数据查询语言 DCL 数据控制语言 2 MYSQL相关操作2.1配置文件my.ini是MySQL的配置文件 2.2登陆/退出MySQL2.2.1登陆 mysql -uroot -p mysql uroot -proot得到版本号 mysql -V mysql –version登陆时候同时打开指定的数据库 mysql -uroot -p -D db_name 2.2.2退出 exit quit 2.2.3 登陆信息中需要掌握的 命令行结束符默认使用;或者\g来结束 可以通过help或者\h或者？加上相关关键字来查看手册 \c可以取消当前命令的执行 2.3 SQL语句语法规范 常用MySQL的关键字我们需要大写 库名，表名字段名称使用小写 SQL语句支持拆行操作，但是不能把完整的单词拆开 数据库名称，表名称，字段名称不要使用MySQL的保留字，如果使用需要用反引号``将其括起来. 2.4 常用SQL语句 SELECT USER() 得到登陆用户 SELECT VERSION() 得到MySQL的版本信息 SELECT NOW() 得到当前的日期时间 SELECT DATABASE() 得到当前打开的数据库 3.数据库的相关操作3.1创建数据库CREATE{DATABASE|SCHEMA}db_name; 检测数据库名称是否存在，不存在则创建 CREATE DATABASE [IF NOT EXISTS] db_name; 在创建数据库的时候指定编码方式 CREATE DATABASE [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset; 3.2查看当前服务器下全部数据库SHOW DATABASES|SCHEMAS; 3.2查看指定数据库的详细信息SHOW CREATE DATABASE db_name; 3.3修改指定数据库的编码方式ALTER DATABASE db_name [DEFAULT] CHARACTER SET [=] charset; 3.4打开指定数据库USE db_name; 3.5得到当前打开的数据库SELECT DATABASE()|SCHEMA(); 3.6删除指定的数据库DROP DATABASE db_name; 如果数据库存在则删除DROP DATABASE [IF EXISTS] db_name; 4数据表的相关操作4.1数据表 是数据库最重要的组成部分之一，数据是保存在数据表中 数据表由行(row)和列(column)来组成 每个数据表中至少有一列，行可以有零行一行或者多行组成 表名要求唯一，不要包含特殊字符，最好含义明确 4.2创建表 CREATE TABLE [IF NOT EXISTS] tbl_name( 字段名称 字段类型 [完整性约束条件], 字段名称 字段类型 [完整性约束条件], ... )ENGINE=存储引擎 CHARSET=编码方式; 完整性约束条件： UNSIGNED无符号，没有负数，从0开始 ZEROFILL零填充，当数据的显示长度不够的时候可以使用前补0的效果填充至指定长度,字段会自动添加UNSIGNED NOT NULL非空约束，也就是插入值的时候这个字段必须要给值,值不能为空 DEFAULT默认值，如果插入记录的时候没有给字段赋值，则使用默认值 PRIMARY KEY主键，标识记录的唯一性，值不能重复，一个表只能有一个主键，自动禁止为空 AUTO_INCREMENT自动增长，只能用于数值列，而且配合索引使用,默认起始值从1开始，每次增长1 UNIQUE KEY唯一性，一个表中可以有多个字段是唯一索引，同样的值不能重复，但是NULL值除外 FOREIGN KEY外键约束 4.3查看当前数据库下已有的数据表 SHOW TABLES; SHOW [FULL] TABLES [{FROM | IN} db_name][LIKE ‘pattern’ | WHERE expr] 4.4查看表结构 DESC tbl_name; DESCRIBE tbl_name; SHOW COLUMNS FROM tbl_name; 4.5查看指定数据表的详细信息SHOW CREATE TABLE tbl_name; 4.6删除数据表DROP TABLE [IF EXISTS] tbl_name; 4.7 表结构相关操作 添加字段 ALTER TABLE tbl_name ADD 字段名称 字段属性 [完整性约束条件] [FIRST|AFTER 字段名称] 删除字段 ALTER TABLE tbl_name DROP 字段名称 添加默认值 ALTER TABLE tbl_name ALTER 字段名称 SET DEFAULT 默认值; 删除默认值 ALTER TABLE tbl_name ALTER 字段名称 DROP DEFAULT 修改字段类型、字段属性 ALTER TABLE tbl_name MODIFY 字段名称 字段类型 [字段属性] [FIRST | AFTER 字段名称] 修改字段名称、字段类型、字段属性 ALTER TABLE tbl_name CHANGE 原字段名称 新字段名称 字段类型 字段属性 [FIRST | AFTER 字段名称] 添加主键 ALTER TABLE tbl_name ADD PRIMARY KEY(字段名称) 删除主键 ALTER TABLE tbl_name DROP PRIMARY KEY; 添加唯一 ALTER TABLE tbl_name ADD UNIQUE KEY|INDEX [index_name] (字段名称) 删除唯一 ALTER TABLE tbl_name DROP index_name; 修改数据表名称 ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name RENAME TABLE tbl_name TO new_tbl_name; 修改AUTO_INCREMENT的值 ALTER TABLE tbl_name AUTO_INCREMENT=值 5.MYSQL中的数据类型5.1数值型整数型 浮点型 5.2字符串类型 字符串类型 CHAR效率高于VARCHAR,CHAR相当于拿空间换时间，VARCHAR拿时间换空间CHAR默认存储数据的时候，后面会用空格填充到指定长度；而在检索的时候会去掉后面空格；VARCHAR在保存的时候不进行填充，尾部的空格会留下TEXT列不能有默认值,检索的时候不存在大小写转换 5.3日期时间类型]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础之数据类型]]></title>
    <url>%2F2019%2F10%2F09%2FMySQL%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.添加记录 INSERT [INTO] tbl_name[(col_name,…)] {VALUE|VALUES}(VALUES…); 1.1不指定字段名称 INSERT tbl_name VALUE(value…) eg：INSERT user VALUE(‘zh’,’12456’); 需要按照建表时的字段顺序给每一个字段赋值 1.2指定字段名称 INSERT tbl_name(字段名称,…) VALUES(值,…) eg:INSERT user(username,id) VALUES(‘zh’,’123456’); INSERT tbl_name SET 字段名称=值,…; eg:INSERT user SET username=’zy’; 1.3INSERT … SELECT INSERT tbl_name[(字段名称…)] SELECT 字段名称,… FROM tbl_name [WHERE 条件] eg:INSERT user(username) SELECT username FROM user2; 1.4一次添加多条记录 INSERT tbl_name[(字段名称,…)] VALUES(值,…),(值,….),(值,…) eg:INSERT user(username,id)VALUSES(‘ZH’,’56’),(‘ZHO’,’57’),(‘ZHY’,’58’), 2.修改记录 UPDATE tbl_name SET 字段名称=值,字段名称=值 [WHERE 条件] eg:UPDATE user SET age=29 WHERE ID=1; 3.删除记录 DELETE FROM tbl_name [WHERE 条件] eg:DELETE FROM user WHERE id=’1’; (如果不添加条件，表中所有记录都会被删除) DELETE 清空数据表的时候不会重置AUTO_INCREMENT的值，可以通过ALTER 语句将其重置为1. ALTRER TABLE user AUTO_INCREMENT=1; 彻底清空数据表 TRUNCATE [TABLE] tbl_name; 清除表中所有记录 会重置AUTO_INCREMENT的值 4.查询记录 SELECT * FROM tbl_name;(查询所有字段) SELECT 字段名称,… FROM tbl_name(查询指定字段的信息) SELECT 字段名称,… FROM db_name.tbl_name;(查询指定库名.表名) SELECT 字段名称 [AS] 别名名称,… FROM db_name.tbl_name; (给字段起别名) SELECT 字段名称 ,… FROM tbl_name [AS] 别名;(给数据表起别名) SELECT tbl_name.col_name,… FROM tbl_name;(表名.字段) 4.1 WHERE 条件 WHERE会筛选出符合条件的记录 比较运算符= &lt; &lt;= != &lt;&gt; &lt;=&gt; &lt;=&gt; 和 =的区别 :&lt;=&gt;可以检测NULL值.但是=不行 IS [NOT] NULL ：检测值是否为NULL或者NOT NULL 指定范围：[NOT] BETWEEN … AND 指定集合：[NOT] IN(值,…) 逻辑运算符:AND 逻辑与 OR 逻辑或 匹配字符 [NOT] LIKE % 任意长度的字符串 _ 任意一个字符 4.2 GROUP BY 分组 一般配合聚合函数使用 COUNT():统计记录总数 (如果写的是COUNT(字段名称)，字段中的值为NULL，不统计进来,写 COUNT(*)会统计NULL值) SUM():求和 MAX():求最大值 MIN():求最小值 AVG():求平均值 配合WITH ROLLUP关键使用 会在记录末尾添加一条记录，是上面所有记录的总和 4.3 HAVING HAVING子句对分组结果进行二次筛选 在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。 SELECT Customer,SUM(OrderPrice) FROM Orders GROUP BY Customer HAVING SUM(OrderPrice)&lt;20004.4 ORDER BY 排序 ORDER BY 字段名称 ASC|DESC 4.5 LIMIT 限制结果集显示条数 LIMIT offset,row_count从offset开始，显示几条记录,offset从0开始 5.多表查询5.1笛卡尔积的形式建立user表: CREATE TABLE IF NOT EXISTS user ( id INT UNSIGNED AUTO_INCREMENT KEY COMMENT&apos;编号&apos;, username VARCHAR(20) NOT NULL UNIQUE COMMENT &apos;用户名&apos;, age TINYINT UNSIGNED DEFAULT 18 COMMENT&apos;年龄&apos;, email VARCHAR(50) NOT NULL DEFAULT &apos;IMMOC@QQ.COM&apos;COMMENT&apos;邮箱&apos;, sex ENUM(&apos;男&apos;,&apos;女&apos;,&apos;保密&apos; )NOT NULL DEFAULT &apos;保密&apos; COMMENT&apos;性别&apos;, depId TINYINT UNSIGNED NOT NULL COMMENT&apos;部门对应的编号&apos; )ENGINE=INNODB CHARSET=UTF8; INSERT user(username,age,depId) VALUES(&apos;king&apos;,24,1), (&apos;lili&apos;,24,2), (&apos;luce&apos;,24,1), (&apos;rose&apos;,24,6), (&apos;lll&apos;,24,1);建立dep表: CREATE TABLE dep( id TINYINT UNSIGNED AUTO_INCREMENT KEY, depName VARCHAR(50) NOT NULL UNIQUE, depDesc VARCHAR(50) NOT NULL )ENGINE=INNODB CHARSET=UTF8; INSERT dep(depName,depDesc) VALUES(&quot;PHP教学部&quot;,&quot;研发PHP课件&quot;), (&quot;java&quot;,&quot;研发java课件&quot;), (&quot;html&quot;,&quot;研发html课件&quot;), (&quot;python&quot;,&quot;研发python课件&quot;); SELECT user.id,user.username,user.age,dep.depName FROM user,dep; +----+----------+------+-----------+ | id | username | age | depName | +----+----------+------+-----------+ | 1 | king | 24 | html | | 1 | king | 24 | java | | 1 | king | 24 | PHP教学部 | | 1 | king | 24 | python | | 2 | lili | 24 | html | | 2 | lili | 24 | java | | 2 | lili | 24 | PHP教学部 | | 2 | lili | 24 | python | | 3 | luce | 24 | html | | 3 | luce | 24 | java | | 3 | luce | 24 | PHP教学部 | | 3 | luce | 24 | python | | 4 | rose | 24 | html | | 4 | rose | 24 | java | | 4 | rose | 24 | PHP教学部 | | 4 | rose | 24 | python | | 5 | lll | 24 | html | | 5 | lll | 24 | java | | 5 | lll | 24 | PHP教学部 | | 5 | lll | 24 | python | +----+----------+------+-----------+5.2内连接 SELECT 字段名称,… FROM tbl_name1 INNER JOIN tbl_name2 ON 连接条件 SELECT u.id,u.username,u.age,d.depName FROM user As u INNER JOIN dep AS d ON u.depId=d.Id;5.3左外连接 SELECT 字段名称,… FROM tbl_name1 LEFT [OUTER] JOIN tbl_name2 ON 条件; 先显示左表中的全部记录，再去右表中查询复合条件的记录，不符合的以NULL代替 SELECT u.id,u.username,u.age,d.depName FROM user As u LEFT OUTER JOIN dep AS d ON u.depId=d.Id;插入脏数据 INSERT user(username,age,depId) VALUES(‘测试用户’,’18’,’8’); +----+----------+------+-----------+ | id | username | age | depName | +----+----------+------+-----------+ | 1 | king | 24 | PHP教学部 | | 2 | lili | 24 | java | | 3 | luce | 24 | PHP教学部 | | 4 | rose | 24 | NULL | | 5 | lll | 24 | PHP教学部 | | 6 | 测试用户 | 18 | NULL | +----+----------+------+-----------+5.4右外连接 SELECT 字段名称,… FROM tbl_name1 RIGHT [OUTER] JOIN tbl_name2 ON 条件; 先显示右表中的全部记录，再去左表中查询复合条件的记录，不符合的以NULL代替 SELECT u.id,u.username,u.age,d.depName FROM user As u RIGHT OUTER JOIN dep AS d ON u.depId=d.Id; +------+----------+------+-----------+ | id | username | age | depName | +------+----------+------+-----------+ | 1 | king | 24 | PHP教学部 | | 2 | lili | 24 | java | | 3 | luce | 24 | PHP教学部 | | 5 | lll | 24 | PHP教学部 | | NULL | NULL | NULL | html | | NULL | NULL | NULL | python | +------+----------+------+-----------+6.外键约束 只有InnoDB存储引擎支持外键 6.1创建外键建表时指定外键 [CONSTRAINT 外键名称 ]FOREIGN KEY(字段名称) REFERENCES 主表(字段名称) 子表的外键字段和主表的主键字段类型要相似；如果是数值型要求一致，并且无符号也要一致；如果是字符型，要求类型一致，长度可以不同 如果外键字段没有创建索引，MySQL会自动帮我们添加索引 子表的外键关联的必须是父表的主键 REATE TABLE new_cate ( id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT KEY, cateName VARCHAR(50) NOT NULL UNIQUE, cateDesc VARCHAR(100) NOT NULL DEFAULT &apos;&apos; )ENGINE=INNODB CHARSET=UTF8; CREATE TABLE news ( id INT UNSIGNED AUTO_INCREMENT KEY, title VARCHAR(100) NOT NULL UNIQUE, content VARCHAR(1000)NOT NULL, cateId TINYINT UNSIGNED NOT NULL, CONSTRAINT cateId_fk_newsCate FOREIGN KEY(cateId) REFERENCES new_cate(id) )ENGINE=INNODB CHARSET=UTF8;动态删除外键 ALTER TABLE tbl_name DROP FOREIGN KEY fk_name; eg:ALTER TABLE news Drop FOREIGN KEY cateId_fk_newsCate; 动态添加外键 ALTER TABLE tbl_name ADD [CONSTRAINT 外键名称] FOREIGN KEY(外键字段) REFERENCES 主表(主键字段); ALTER TABLE news ADD FOREIGN KEY(cateId) REFERENCES new_cate(id); ALTER TABLE news ADD CONSTRAINT cateId_fk_newsCate FOREIGN KEY(cateId) REFERENCES new_cate(id);6.2 外键约束的参照操作 CASCADE从父表删除或更新，子表也跟着删除或者更新，级联的操作 eg:ALTER TABLE news ADD FOREIGN KEY(cateId) REFERENCES news_cate(id) ON DELETE CASCADE ON UPDATE CASCADE; SET NULL 从父表删除或者更新记录，并设置子表的外键列为NULL。 NO ACTION | RESTRICT 拒绝对父表做更新或者删除操作 7.特殊形式的查询7.1子查询 内层语句查询的结果可以做为外层语句查询的条件 SELECT 字段名称 FROM tbl_name WHERE col_name=(SELECT col_name FROM tbl_name) 由IN引发的子查询 SELECT * FROM user WHERE id IN(SELECT id FROM dep); 比较运算符引出的子查询 SELECT id,username,score FROM stu WHERE score&gt;=(SELECT score FROM level WHERE id=1); 由EXISTS引发的子查询 如果exists 后面为真就执行 SELECT * FROM emp WHERE EXISTS(SELECT depName FROM dep WHERE id=10); ANY SOME ALL 当&gt;,&gt;=’ ANY:查询最小值 SOME:查询最小值 ALL:查询最大值 当&lt;=,&lt; ANY:查询最大值 SOME:查询最大值 ALL:查询最大值 当 = ANY:查询任意值 SOME:查询任意值 当 &lt;&gt; !=:ALL :查询任意值 建表时候直接插入数据 CREATE TABLE user1 ( id INT UNSIGNED AUTO_INCREMENT KEY, username VARCHAR(20) )SELECT id,username FROM user; 将user表中的用户名写到user1表中 INSERT user1(username) SELECT username from user; 创建和user1表结构相同的user2 CREATE TABLE user2 LIKE user1; 将user1表中的数据添加到user2中 INSERT user2 SELECT id,username from user1;INSERT user2 SET username=(SELECT username from user1 WHERE id=2); 去掉字段的重复值 SELECT DISTINCT(username)FROM user2; 7.2 联合查询 UNION ALL 是简单的合并，UNION会去掉表中重复记录 UNION SELECT 字段名称,… FROM tbl_name1 UNION SELECT 字段名称… FROM tbl_name2; UNION ALL SELECT 字段名称,… FROM tbl_name1 UNION ALL SELECT 字段名称… FROM tbl_name2; select * from user1 UNION select * from user27.3 自身连接查询无限级分类的实现形式 REATE TABLE cate( id SMALLINT UNSIGNED AUTO_INCREMENT KEY, cateName VARCHAR(100) NOT NULL UNIQUE, pId SMALLINT UNSIGNED NOT NULL DEFAULT 0 ); INSERT cate(cateName,pId) VALUES(&apos;服装&apos;,0); INSERT cate(cateName,pId) VALUES(&apos;数码&apos;,0); INSERT cate(cateName,pId) VALUES(&apos;箱包&apos;,0); INSERT cate(cateName,pId) VALUES(&apos;男装&apos;,1); INSERT cate(cateName,pId) VALUES(&apos;女装&apos;,1); INSERT cate(cateName,pId) VALUES(&apos;内衣&apos;,1); INSERT cate(cateName,pId) VALUES(&apos;电视&apos;,2); INSERT cate(cateName,pId) VALUES(&apos;冰箱&apos;,2); INSERT cate(cateName,pId) VALUES(&apos;洗衣机&apos;,2); INSERT cate(cateName,pId) VALUES(&apos;爱马仕&apos;,3); INSERT cate(cateName,pId) VALUES(&apos;LV&apos;,3); INSERT cate(cateName,pId) VALUES(&apos;GUCCI&apos;,3); INSERT cate(cateName,pId) VALUES(&apos;夹克&apos;,4); INSERT cate(cateName,pId) VALUES(&apos;衬衫&apos;,4); INSERT cate(cateName,pId) VALUES(&apos;裤子&apos;,4); INSERT cate(cateName,pId) VALUES(&apos;液晶电视&apos;,10); INSERT cate(cateName,pId) VALUES(&apos;等离子电视&apos;,10); INSERT cate(cateName,pId) VALUES(&apos;背投电视&apos;,10); 查询分类信息，并且得到其父类 SELECT s.id,s.cateName AS sCateName,p.cateName AS pCateName FROM cate AS s LEFT JOIN cate AS p ON s.pId=p.id; 查询所有的分类及其子分类 SELECT p.cateName AS pCateNames,s.id,s.cateName AS sCateName FROM cate AS s RIGHT JOIN cate AS p ON s.pId=p.id; 查询子分类和数目 SELECT p.id,p.cateName AS pCateNames,s.cateName AS sCateName,COUNT(s.cateNa me) AS count FROM cate AS s RIGHT JOIN cate AS p ON s.pId=p.id GROUP BY p.cateName;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[题目：最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 输入: [“flower”,”flow”,”flight”]输出: “fl”示例 2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 思路1考虑特例:如果字符数组只有一个字符串则返回为该字符串。 以字符数组中的第一个字符串作为基础字符串，如果基础字符串为空，返回空，如果不为空，则与后面n个字符串进行比较。 把基准字符串转换程字符数组。把它后续要比较的字符串也转换成字符数组。同样如果被比较的字符数组为空也返回空。 然后定义一个计数器，记录基准字符串和后续的字符串相同的位数是几位。定义一个变量sum记录每次比较计数数值最小的那个。 当比较结束之后得到sum。将目标数组的前sum个字符输出就是最长公共长缀。 代码 class Solution { public String longestCommonPrefix(String[] strs) { if(strs.length==0) return “”; if(strs.length==1) return (String)strs[0]; char[] a=strs[0].toCharArray(); if(a.length==0) return “”; int sum=a.length; for(int j=1;j&lt;strs.length;j++) { int count=0; char [] aa=strs[j].toCharArray(); if(aa.length==0) { return “”; } for(int i=0;i&lt;aa.length&amp;&amp;i&lt;a.length ;i++) { if(aa[i]==a[i]) { count++; } else { break; } } sum=Math.min(sum,count); } String longl =””; for(int i=0;i&lt;sum;i++) { longl=longl+a[i]; } return longl; }} 思路2也是把第一个字符串作为基础字符串。然后每次和后面的字符串进行判断。利用indexOf(prefix) != 0 来说明该字符串不是它的公共前缀，那么就要进行剪切。 直到剪切后的字符串是后面的每个字符串的公共前缀，如果该字符剪切到长度为零了，证明没有公共前缀。返回null。 代码public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return “”; String ss= strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(ss) != 0) { ss = ss.substring(0, ss.length() - 1); if (ss.isEmpty()) return “”; } return ss;}]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode--字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目:最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 中心扩展算法通过观察回文串的特点我们知道，回文串是以中心为对称轴两边镜像的。 那么我们就遍历整个字符串，把每个字符作为中心轴，这是假设回文串长度是奇数的情况下。 还有一种情况是假设回文串长度是偶数。那么就以该字符和下一个字符的中间为中心轴。 确定好中心轴之后我们就要开始展开。 如果该字符的前面一个和该字符的后面一个字符相等的话就扩展范围。再比较前面的第二个和后面的第二个依次类推。 返回每次范围长度，取最长为答案。 代码class Solution { public String longestPalindrome(String s) { if(s==null||s.length()&lt;1) return &quot;&quot;;//特例判断如果字符串的长度为0,或者为null返回空字符串 int len=s.length(); int start=0; int end=0; for(int i=0;i&lt;len;i++) { int len1=centerexpand(s,i,i);//假设回文串长度为奇数的情况 int len2=centerexpand(s,i,i+1);//假设回文串长度为偶数的情况 int len3=Math.max(len1,len2); //更新开始start和结束end的值。 if(len3&gt;end-start) { start=i-(len3-1)/2; end=i+len3/2; } } return s.substring(start,end+1);} public int centerexpand(String s,int left,int right) { while(left&gt;=0&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))//如果满足进行扩展，并更新边界索引值。 { left--; right++; } return right-left-1; } }暴力暴力的思路很简单，但是时间复杂度很高是O(n³)。 需要一个函数来单独判断是不是回文串。判断第一个和最后一个是否相等。第二个与倒数第二个是否相等..按顺序依次比较。 如果是的话返回true。否则返回flase. 再双层循环遍历该字符串，i作为字符串的开头。j作为字符串的结尾。对每次判断截取的字符串s.substring(i,j) 判断是不是回文串.如果是则记录下该字符串长度。用ans保存长度的最大值。最后的ans为答案。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode--字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F29%2F%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。2–abc3–def4–ghi5–jkl6–mno7–pqrs8–tuv9–wxyz 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 思路先把数字和字符的映射关系都存到map中，注意map在调用put方法时候不能在类体中执行，需要在方法中或是静态块中执行。所以我们要把它放在某个特定的方法中。 这道题用到了回溯的思想，也就是穷举所有可能，定义一个back回溯函数，变量是connection字符串用于存放符合题意的中间字符串。再定义一个index字符串变量用来保存接下来每个数字。遍历该数字对应的字符串的所有字符。如果可行的话就将字符添加到connection字符串后面。如果不可行的话就回溯到上一次执行的地方。 具体操作：设定一个list用来存储要输出的字符串。 在back中将输入的数字截取字符串分割成每个单个数字。然后从map中提取对应的键值。再对键值中的字符串进行分割提取每个字符。将该字符添加到connection后面，将该字符如果后面还有数字的话，就往下走寻找下一个数字对应的字符串中的某个字符。如果没有数字了，就把connection字符串添加到list中。回溯到上一次指定的地方，直到没有可能的地方走。 代码 class Solution { List&lt;String&gt; outputlist=new ArrayList&lt;&gt;(); public void back(String connection,String index) { Map&lt;String,String&gt;map=new HashMap&lt;&gt;(); map.put(&quot;2&quot;,&quot;abc&quot;); map.put(&quot;3&quot;,&quot;def&quot;); map.put(&quot;4&quot;,&quot;ghi&quot;); map.put(&quot;5&quot;,&quot;jkl&quot;); map.put(&quot;6&quot;,&quot;mno&quot;); map.put(&quot;7&quot;,&quot;pqrs&quot;); map.put(&quot;8&quot;,&quot;tuv&quot;); map.put(&quot;9&quot;,&quot;wxyz&quot;); if(index.length()==0) { outputlist.add(connection); } else { String aindex=index.substring(0,1); String last=map.get(aindex); for(int i=0;i&lt;last.length();i++) { String alast=last.substring(i,i+1); back(connection+alast,index.substring(1)); } } } public List&lt;String&gt; letterCombinations(String digits) { if(digits.length()!=0) { back(&quot;&quot;,digits); } return outputlist; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode--字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F29%2F%E8%B4%AA%E5%BF%83-%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路看到题目首先要确定什么时候买股票什么时候卖股票获得利益最大。通过分析我们知道:一个有三种情况。分别是： 第一种：连续增长日，股票连续几天都在增长。[1,2,3,4];那么他的最大利益就等于最后增长的那天股票价钱减去第一天股票的价钱。也相当于第一天买第二天卖。第二天买，第三天卖。 第二种：连续下降日，这种时候不能卖。因为卖了就赔。 第三种：普通情况[1,3,2,5,4] 我们此时应该第一天买 第二天卖 第三天买 第四天卖总利益最大是2+3=5; 综上我们发现三种情况都有一个共同的特点就是我们不需要考虑什么时候买，只需要考虑什么时候卖就行。那么什么时候卖呢。就是对比前一天。如果发现它比前一天涨价了 就今天卖，昨天买，永远遵循这个原则那么就可以获得最大的利益。 具体实现遍历每天的股票钱数。如果今天比昨天股票上涨了那么利益为正。加到最终的利益中，如果今天比昨天股票下降了那么利益为负，不能加到最终的利益当中。 代码class Solution { public int maxProfit(int[] prices) { int profit = 0; for (int i = 1; i &lt; prices.length; i++) { int tmp = prices[i] - prices[i - 1]; if (tmp &gt; 0) profit += tmp; } return profit; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode--贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F28%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目 给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。 示例: 输入: s = “abcdefg”, k = 2输出: “bacdfeg”要求: 该字符串只包含小写的英文字母。给定字符串的长度和 k 在[1, 10000]范围内。 思路如果该字符串的长度大于2k,那么就截取它前2k个字符。进行翻转。 如果该字符串的长度小于2*k。但是大于k;直接将前k个进行翻转。 如果该字符串的长度小于k。就把这些字符都进行翻转。 每次翻转后都要截取掉翻转后的字符串。将剩余的字符串进行判断。 代码class Solution { public String reverseStr(String s, int k) { String ss=&quot;&quot;; while(s.length()&gt;=2*k) { String as=s.substring(0,2*k);//截取前2*k个字符 char []a=as.toCharArray(); char[] b=new char[k]; char t; for(int i=0,j=k-1;i&lt;k;i++,j--) { t=a[i]; b[j]=t; } ss=ss+String.valueOf(b)+as.substring(k); s=s.substring(2*k); } if(s.length()&gt;=k) { char[]a=s.toCharArray(); char []b=new char[k]; char u; for(int i=0,j=k-1;i&lt;k;i++,j--) { u=a[i]; b[j]=u; } ss=ss+String.valueOf(b)+s.substring(k); } else if(s.length()&gt;0) {char[]b=new char[s.length()]; char[]a=s.toCharArray(); char t; for(int i=0,j=s.length()-1;i&lt;s.length();i++,j--) { t=a[i]; b[j]=t; } ss=ss+String.valueOf(b); } return ss; } }反思 这种方法代码写的又臭又长。后来看了官方的代码。有了点思路。 我其实没必要判断剩下的串的长度是不是大于k小于2*k，还是小于k。 只用判断翻转边界即可，在翻转边界之内进行翻转。然后指向边界开头的指针i每次指的位置的索引都加上2*k; 官方代码思路把一个字符串分成块，定义两个变量i，j i指向每个块2k的第一个， j指向2k中的k的位置。然后通过i++，j–进行反转交换如果这个最后一个块不满足k个元素了。那么通过j = Math.min(i+ k - 1, a.length - 1);来确定块边界位置，从而进行翻转 代码class Solution { public String reverseStr(String s, int k) { char[] a=s.toCharArray(); for(int i=0;i&lt;a.length;i=i+2*k) { int ss=i; int j=Math.min(a.length-1,i+k-1); while(ss&lt;j) { char temp=a[ss]; a[ss++]=a[j]; a[j–]=temp; } } return new String(a); }}]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Freemarker]]></title>
    <url>%2F2019%2F09%2F25%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[模板引擎什么是模板引擎 模板引擎的目标是”数据+模板=结果” 模板引擎将数据与展现有效”解耦” 主流模板引擎 java Server Page Freemarker Beetl Freemarker FreeMarker是免费开通的模板引擎技术 FreeMarker脚本为FreeMarker Template Language FreeMarker提供了大量的内建函数来简化开发 如何使用Freemarker我们要定义在Freemarker官网下载所对应的jar包然后将该jar包放在WEB-INF/lib 下 书写简单的Freemarker 1.加载模板 2.创建数据 3.结果输出 代码 package com.freemarker; import java.io.IOException; import java.io.OutputStreamWriter; import java.util.HashMap; import java.util.Map; import freemarker.core.ParseException; import freemarker.template.Configuration; import freemarker.template.MalformedTemplateNameException; import freemarker.template.Template; import freemarker.template.TemplateException; import freemarker.template.TemplateNotFoundException; public class FreemarkerSample1 { public static void main(String[] args) throws TemplateNotFoundException, MalformedTemplateNameException, ParseException, IOException, TemplateException { // TODO Auto-generated method stub // 1.加载模板 //创建核心配置对象 Configuration config=new Configuration(Configuration.VERSION_2_3_29); //设置加载的目录 config.setClassForTemplateLoading(FreemarkerSample1.class, &quot;&quot;);//空字符串代表当前包 //得到模板对象 Template t=config.getTemplate(&quot;sample1.ftl&quot;); // 2.创建数据 Map&lt;String,Object&gt; data=new HashMap&lt;String,Object&gt;(); data.put(&quot;site&quot;,&quot;百度&quot;); data.put(&quot;url&quot;,&quot;http://www.baidu.com&quot;); //. 3.产生输出 t.process(data,new OutputStreamWriter(System.out));// 字节转字符} }FTL取值 ${属性值} ${属性值!默认} 属性值不存在的时候默认值输出 ${属性值？string(“ “)} 规格化输出 实例1data.put(&quot;size&quot;,&quot;baidu&quot;); data.put(&quot;url&quot;,&quot;www.baidu.com&quot;); 在ftl中 ${size}--${url}输出结果 百度–www.baidu.com 实例2data.put(&quot;size&quot;,&quot;baidu&quot;); ${sizo?不存在的属性};结果： 不存在的属性 说明： 我们并没有定义sizo属性。所以显示不存在的值。如果不这样写的话。程序会报错。 示例3data.put(&quot;number&quot;,8485.2333);ftl中 ${number}; 输出结果 8485.2333 说明freemarker默认只保存小数点后三位 如果想要保存两位数字就要用到格式化输出${属性值？string(“ “)} ${number？string(&quot;0.00&quot;)};输出结果 8485.23 实例4日期的输出要用到规格化。 data.put(&quot;data&quot;,new Data()); $(data?string(&quot;yyyy年MM月dd日 HH:mm:ss SSS&quot;));输出结果 2019年9月26日 15:12:122 实例5在freemarker中也是可以输出对象 比如定义一个Computer类属性如下： private String sn;//序列号 private String modle;//电脑品牌 private int state;//状态 private String user;//使用人 private Date dop;//采购日期 private Float price; private Map info;// 我们注意到info 的属性是Map Map info=new HashMap(); infp.put(&quot;cpu&quot;,&quot;i5&quot;); Computer computer=new Computer(&quot;123456&quot;,&quot;Thinkpad&quot;,1,&quot;lucy&quot;,&quot;new Data(),20000f，info); data.put(&quot;computer&quot;,computer);ftl中 ${computer.sn} ${computer.modle} ${computer.state} ${computer.user} ${computer.dop?string(&quot;yyyy年MM月dd日 HH:mm:ss SSS&quot;)} ${computer.info(&quot;cpu&quot;)}map中的输出值用[]括起来 分支判断1.if&lt;#if 条件1&gt; 条件1下执行的代码 &lt;#elseif 条件2&gt; 条件2下执行的代码 &lt;#elseif 条件3&gt; 条件3下执行的代码 &lt;#else&gt; &lt;/#if&gt;实例1&lt;#if computer.sn==&quot;123456&quot;&gt;&lt;#-- 字符串判断直接就用== --&gt; 重要设备 &lt;/#if&gt; ${computer.modle} &lt;#if computer.state==1&gt; 状态正在使用 &lt;#elseif compuer.state==2&gt; 状态闲置 &lt;#elseif computer.state==3&gt; 状态已作废 &lt;/#if&gt; &lt;#if computer.user??&gt; &lt;#--？？判断对象是否是空--&gt; 用户: ${computer.user} &lt;/#if&gt; Computer computer=new Computer(“123456”,”Thinkpad”,1,”lucy”,”new Data(),20000f，info); 输出 重要设备 状态正在使用 lucy 2.switch&lt;#switch computer.state&gt; &lt;#case 1&gt; 正在使用 &lt;#break&gt; &lt;#case 2&gt; 闲置 &lt;#break&gt; &lt;#case 3&gt; 作废 &lt;#break&gt; &lt;#default&gt; 无效状态 &lt;/#switch&gt;迭代列表&lt;#list list as v&gt; &lt;li&gt;${v_index}---${v.name}&lt;/li&gt; &lt;/#list&gt; index是索引值实例1&lt;#list computers as c&gt; 迭代集合和集合迭代变量 序号:${c_index} &lt;#-- 迭代变量_index保存了循环的索引，从0开始 --&gt; ${c_index+1 &lt;#-- 迭代变量_index保存了循环的索引，从1开始 --&gt; ${c.sn} ${c.modle} &lt;#switch c.state&gt; &lt;#case 1&gt; 使用中 &lt;#break&gt; &lt;#case 2&gt; 闲置 &lt;#break&gt; &lt;#case 3&gt; 作废 &lt;#break&gt; &lt;#default&gt; 无效 &lt;/#switch&gt; &lt;#if c.user??&gt; ${c.user} &lt;/#if&gt; ${c.price?string(&quot;0.00&quot;)} ${c.dop?string(&quot;yyyy年MM月dd日 HH:mm:ss SSS&quot;)} &lt;/#list&gt;创建数据 Map&lt;String,Object&gt; data=new HashMap&lt;String,Object&gt;(); List&lt;Computer&gt; computers=new ArrayList(); computers.add(new Computer(&quot;123456&quot;,&quot;levet&quot;,1,&quot;dfef&quot;,new Date(),12900f,new HashMap())); computers.add(new Computer(&quot;123456&quot;,&quot;lll&quot;,1,&quot;efef&quot;,new Date(),12900f,new HashMap())); computers.add(new Computer(&quot;123456&quot;,&quot;aa&quot;,3,&quot;fege&quot;,new Date(),12900f,new HashMap())); computers.add(new Computer(&quot;123456&quot;,&quot;EEEE&quot;,2,&quot;nbr&quot;,new Date(),12900f,new HashMap())); computers.add(new Computer(&quot;123456&quot;,&quot;DGGEG&quot;,1,&quot;nfdefel&quot;,new Date(),12900f,new HashMap())); data.put(&quot;computers&quot;,computers);迭代Map&lt;#list map?keys as key&gt; ${key}--${map[key]} &lt;/#list&gt;实例1&lt;#list computer_map?keys as k&gt; ${k}---${computer_map[k].moble} &lt;/#list&gt; Map&lt;String,Object&gt; data=new HashMap&lt;String,Object&gt;(); List&lt;Computer&gt; computers=new ArrayList(); computers.add(new Computer(&quot;123456&quot;,&quot;levet&quot;,1,&quot;dfef&quot;,new Date(),12900f,new HashMap())); computers.add(new Computer(&quot;1234567&quot;,&quot;lll&quot;,1,&quot;efef&quot;,new Date(),12900f,new HashMap())); computers.add(new Computer(&quot;1234568&quot;,&quot;aa&quot;,3,&quot;fege&quot;,new Date(),12900f,new HashMap())); computers.add(new Computer(&quot;1234569&quot;,&quot;EEEE&quot;,2,&quot;nbr&quot;,new Date(),12900f,new HashMap())); computers.add(new Computer(&quot;12345610&quot;,&quot;DGGEG&quot;,1,&quot;nfdefel&quot;,new Date(),12900f,new HashMap())); data.put(&quot;computers&quot;,computers); //LinkedHashMap按数据的存放顺序进行保存 Map computerMap = new LinkedHashMap(); for(Computer c:computers) { computerMap.put(c.getSn(),c); } data.put(&quot;computer_map&quot;,computerMap);内键函数 substring（start,end）从一个字符串中截取子串 cap_first 首字母大写 index_of 查找字符索引 length 返回字符串长度 round/floor/ceiling 四舍五入/下取整/上取整 size 得到集合元素的总数 first/last 获得第一个/最后一个元素 sort_by 按某个属性值对集合排序 upper_case/lower_case 字母变成大写/小写 实例1 ${name?cap_first} 结果 Jackson ${brand?upper_case} 结果 BMW ${BRAND?lower_case} 结果 bmw data.put(&quot;name&quot;,&quot;jackson&quot;); data.put(&quot;brand&quot;,&quot;bmw&quot;);实例2-${words?index_of(“blood”)} 结果 6 -${words?replace(“blood”,”****”)} 结果 first **** data.put(&quot;words&quot;,&quot;first blood&quot;);实例3&lt;#-- 利用？string实现三目运算符的操作 --&gt; ${(words?index_of(&quot;blood&quot;)!=-1)?string(&quot;包含敏感词汇&quot;,&quot;不包含敏感词汇&quot;)} ${n?round} 答案:37982 ${n?floor} 答案:37981 ${n?ceiling} 答案:37982 data.put(&quot;n&quot;,37981.83);实例4${computers?size} ${computers?first.modle} ${computers?last.modle}&lt;#– 集合排序 –&gt; &lt;#list computers?sort_by(&quot;price&quot;)as c&gt; ${c.sn}--${c.price} &lt;/#list&gt; &lt;#list computers?sort_by(&quot;price&quot;)?reverse as c&gt;&lt;#-- 反方向排序 --&gt; ${c.sn}--${c.price} &lt;/#list&gt;freemmarker与servlet整合步骤1.在eclipse中新建javaWeb工程 2.添加依赖jar包 3.在web.xml中添加freemarker的servlet配置 &lt;servlet&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;TemplatePath&lt;/param-name&gt;//这个是如果请求的名称是.ftl 就到这个TemplatePath：/WEB-INF/ftl 去寻找那个文件。 &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt;// &lt;/servlet-mapping&gt;4.新建servlet protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List list=new ArrayList(); list.add(new Employee(7731,&quot;zhangsan&quot;,&quot;shichangbu&quot;,&quot;kehudaibiao&quot;,80000f)); list.add(new Employee(7732,&quot;zhangsang&quot;,&quot;shichangbu&quot;,&quot;kehudaibiao&quot;,81000f)); request.setAttribute(&quot;employee_list&quot;, list); request.getRequestDispatcher(&quot;/employee.ftl&quot;).forward(request, response); }5.写ftl 文件 &lt;table class=&quot;table table-bordered table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;职务&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;#list employee_list as emp&gt; //emploeelist的请求范围是从请求 会话 context中获取 不管servlet请求对象换成谁。这里都不用变 &lt;tr&gt; &lt;td&gt;${emp_index+1}&lt;/td&gt; &lt;td&gt;${emp.empno?string(&quot;0&quot;)}&lt;/td&gt; &lt;td&gt;${emp.ename}&lt;/td&gt; &lt;td&gt;${emp.department}&lt;/td&gt; &lt;td&gt;${emp.job}&lt;/td&gt; &lt;td style=&quot;color: red;font-weight: bold&quot;&gt;${emp.salary?string(&quot;0.00&quot;)}&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/tbody&gt; &lt;/table&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>Freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F25%2Fjava%E5%8F%8C%E6%8C%87%E9%92%88--%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目盛最多水的容器 给定 n 个非负整数a1，a2，…，an，每个数代表坐标中的一个点 (i, ai)。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。示例: 输入: [1,8,6,2,5,4,8,3,7]输出: 49 思路 用到了双指针的思想。第一次做的时候。我用的是两层循环。 一个指针指向开头。第二个指针指向结尾。然后每次算面积的时候取两个垂直线高度低的高度*他们之间的距离 代码 class Solution { public int maxArea(int[] height) { int sum=0; for(int i=0;i&lt;height.length;i++) { for(int j=height.length-1;j&gt;i;j--) { int v=Math.min(height[i],height[j])*(j-i); sum=Math.max(sum,v); } } return sum; } }这个方法不是很好，只超过了百分之30多。 优化的方式：如果想要面积最大，要么高度高，要么宽度大。高度取决于两个高度之间最小的那个。 可以这么想：两个指针i，j指向前后两个数，如果nums[i]&lt; nums[j] 就说明这次面积计算中的高度被nums[i]拉低了。 我们要移动i，令i++；看是否有更合适的i值，使得该nums[i] 弥补上一个nums[i-1]的高度不足,但同时移动时候宽度减小。 所以我们应该判断这个i是否能通过高度的增加也弥补了本次宽度的减少，使得面积更大. 如果nums[i]&gt;=nums[j],同理就证明本次面积的计算中的高度是nums[j]拉低了。所以我们要j–; 代码class Solution { public int maxArea(int[] height) { int i=0;int j=height.length-1; int sum=0; while(i&lt;j) { sum=Math.max(sum,Math.min(height[i],height[j])*(j-i)); if(height[i]&lt;height[j]) { i++; } else { j--; } } return sum; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F24%2Fjava%E5%8F%8C%E6%8C%87%E9%92%88--%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[题目：删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 题目要点 在原地删除重复出现的元素 不要使用额外的数组空间 只能使用 O(1) 额外空间 思路 不能开辟数组，只能在该数组操作，就想到了双指针的方法。i指针和j指针。j在前面，也就是慢指针，i在j的后面是快指针。 快指针初始化时候指向数组的第二项。 如果nums[i]!=nums[i-1]，就要跳过重复项，i和j同时加一。 如果nums[i]=nums[i-1]的话就移动i，令i+1， 找到nums[i]!=nums[i-1]的i下标对应的数组值。将该值赋值到j下标的数组元素身上依次覆盖。最后数组的前几位一定是有序的无重复数。 记得判断数组是否为空。 代码class Solution { public int removeDuplicates(int[] nums) { if(nums.length==0) return 0; int j=1; for(int i=1;i&lt;nums.length;) { if(nums[i]==nums[i-1]) { i++; } else if(nums[i]!=nums[i-1]) { nums[j]=nums[i]; j++; i++; } } return j; } }执行用时 : 1 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗 :39.8 MB, 在所有 Java 提交中击败了95.22%的用户 类似题目题目：移除元素 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等&gt;val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额&gt;外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 代码class Solution { public int removeElement(int[] nums, int val) { int j=0; if(nums.length==0) return 0; for(int i=0;i&lt;nums.length;) { if(nums[i]==val) { i++; } else if(nums[i]!=val) { nums[j]=nums[i]; i++; j++; } } return j; } }显示详情： 执行用时 :1 ms, 在所有 Java 提交中击败了92.14%的用户 内存消耗 :35.4 MB, 在所有 Java 提交中击败了84.32%的用户]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图书馆管理项目（Ajax,jQuery，JSON,JSTL,正则表达式，过滤器等的应用）]]></title>
    <url>%2F2019%2F09%2F23%2F%E5%9B%BE%E4%B9%A6%E9%A6%86%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[项目需求 主要功能： 1、注册登录功能 注册：信息包括用户名、密码、密码确认、手机号码和邮箱，要使用正则表达式进行校验 登录：注册成功直接跳转到登录页面，登录成功后显示用户名 登录成功后进入管理页面。 使用过滤器限制不登录不能进入管理页面 2、图书分类管理 分类添加：分类id、名字、描述 3、图书管理 图书添加：内容包括图书id、图书名、图书分类、价格、描述 图书查询：列出所有图书完整信息，可以按id、图书名、分类进行查询，使用Ajax局部刷新，显示所有图书时要使用jstl 实现过程:注册功能的实现：注册包括用户名，密码，密码确认，手机号码和邮箱并且都要进行正则表达式进行校验 所以我们要用js写一个事件。比如说用户名，当失去鼠标焦点的时候就触发一个事件。该事件要做的就是要判断该用户名是否满足需求 定义一个正则表达式。用正则表达式的text方法来检验name的值是否正确。不正确的话就清除该文本框的内容并让用户重新输入。 密码确认的时时候要比较两次密码输入是否一致，不一致也要清除文本框，让用户重新输入。 我们在点击提交的时候，要将页面跳转到一个RegistServlet里面，目的是进行用户信息的保存。以便于用户登陆时信息的比对。 因为有多个用户。所以我们在进行信息保存的时候通常保存在一个列表里面，列表的中保存的类型是用户类。 那么我们要先创建一个用户类：属性是用户的名字，密码，手机，和邮箱号。还有getter，setter方法。构造函数方法。 接着我们在一个操作类中保存这个用户。定义一个操作类为LibDaoImpl，在这里定义一个 private static final Listuserlist=new ArrayList();用来保存用户列表。还有一个方法是addUserList(User user)//用来添加用户。 我们在servlet中用request.getParameter(“”)方法提取出用户的属性值。利用用户类的构造函数方法对User类进行初始化。调用LibDaoImpl中的addUserList（User user）方法将该注册用户添加到列表里。 登陆功能的实现登陆的时候，我们有两点需要注意：第一点，我们先判断该用户是否注册过，第二点，我们判断该用户的用户名和用户密码是否输入正确 我们判断的唯一依据就是根据注册时，我们保存的用户列表。因为用户列表是private 我们要通过公有的方法去访问到该列表。 我们首先看该列表有没有登陆时候输入的用户名。那么我们在LibDaoImpl中创建的方法就应该是public boolean isexits(String username） 我们在LoginServlet页面利用request.getParemeter(“”)方法获取用户的用户名。 然后调用isexits方法如果返回值为false。让它跳转到注册页面。如果是ture就要进行下一步的用户名和密码是否正确的验证环节。 同样在LoginServlet中创建一个方法islogin(Stringusername,String password)。 如果返回值为true 就跳转到图书管理页面，如果为false就重新登陆。 我们为了防止用户跳过登陆和注册就直接进入图书管理页面。我们要弄一个过滤器。过滤掉没有登陆的页面。 图书分类添加的实现分类时 有分类id，分类名，分类表述。因为有多个分类，所以我们也利用一个保存分类的列表来存储。存储的数据类型时一个Map用来保存属性和值的信息。在操作类中定义：private static final List&lt;Map&lt;String, Object&gt;&gt; categorys=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();对应的方法是public void addBookCatgory(String id, String catgoryName, String description)与上述过程一样，创建一个servlet CatgoryServlet。获取图书的分类id，分类名，和分类描述，利用方法addBookCatgory()方法来保存图书分类信息。外界过去图书分类用到的方法是public List&lt;Map&lt;String, Object&gt;&gt; getAllBookCatgory()； 如果在图书添加页面分类下拉框中显示分类信息。这时要用到JSTL在addBook.jsp中利用获取图书分类的方法 获取categoryList列表，利用JSTL中的迭代功能进行遍历显示 图书添加的实现 图书添加时候，我们要保存图书信息，建立一个图书类。属性值为bookId，bookName，catgoryName，count，description; 添加getter和setter方法和构造函数的方法。好多图书，用列表来保存。在操作类中定义一个 private static final List addBooklist =new ArrayList&lt;&gt;();对应方法是 addBook(Book book)； 获取图书信息对应的方法是public List getBook(); 在AddBookServlet中利用getparameter方法获取图书信息。利用操作类中添加图书的方法将图书信息存储到图书列表中。 在显示图书页面中利用getBook()方法获取图书信息。 图书查询的实现。我们可以根据图书的id 图书的分类 和图书的名称任意几个属性来获取我们所需要的图书。 那么我们就要在操作类中定义一个方法：该方法就是根据条件来找到对应的图书信息，返回是一个列表。 public List getBookByCondition(String bookId,String bookName,String catoryName) 这个操作的利用了Ajax 的动态刷新。 创建一个Servlet。 SelectBookServlet中我们获取索要查询的图书的分类，id和图书的名称利用 getBookByCondition的方法来获取图书列表，再用JSSON.toJSONString()方法将列表序列化返回到 查询的界面。完成查询，利用ajax 完成动态刷新。 代码静态网页代码 1.初始界面index.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;%String flag=request.getParameter(&quot;flag&quot;); %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type=text/javascript&gt; var flag=&lt;%=flag%&gt; if(flag==1) alert(&quot;该用户用户名或者密码错误&quot;); else if(flag==2) alert(&quot;请先登陆&quot;); else if(flag==3) alert(&quot;已经注册过可直接登陆&quot;); &lt;/script&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书后台管理登录界面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;登录 | &lt;a href=&quot;./regist.jsp&quot;&gt;注册&lt;/a&gt;&lt;/h1&gt; &lt;form action=&quot;./LoginServlet&quot; method=&quot;post&quot;&gt; &lt;table width=&quot;350px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名为3-12位字母数字或下划线组合&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密&amp;nbsp;码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;长度为6-12位的纯数字&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;取消&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;2.注册页面regix &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@page import=&quot;bookclass.LibDaoImpl&quot;%&gt; &lt;%String flag=request.getParameter(&quot;flag&quot;); %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type=text/javascript&gt; var flag=&lt;%=flag%&gt; if(flag==1) alert(&quot;该用户没注册，请注册&quot;); if(flag==2) alert(&quot;该用户已经注册过&quot;); &lt;/script&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;注册界面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;用户注册&lt;/h1&gt; &lt;form action=&quot;./RegistServlet&quot; method=&quot;post&quot;&gt; &lt;table width=&quot;400px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;placeholder=&quot;用户名为3-12位字母数字或下划线组合&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密&amp;nbsp;码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;密码长度为6-12位的纯数字&quot; id=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;确认密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;checkPWD&quot; id=&quot;checkPWD&quot; placeholder=&quot;密码长度为6-12位的纯数字&quot; &quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机号码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;phone&quot; id=&quot;phone&quot; placeholder=&quot;请输入正确的手机号码格式&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入正确邮箱格式&quot; required=&quot;required&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/center&gt; &lt;script type=&quot;text/javascript&quot; &gt; document.getElementById(&quot;password&quot;).onchange=function() { var regex=/^\d{6,12}$/; var password=document.getElementById(&quot;password&quot;).value; if(!(regex.test(password))) { document.getElementById(&quot;password&quot;).value=&quot;&quot;; alert(&quot;密码输入不符合规范，请重新输入&quot;); } } document.getElementById(&quot;username&quot;).onchange=function() { var regex=/^[a-zA-Z0-9_]{3,12}$/; var username=document.getElementById(&quot;username&quot;).value; if(!(regex.test(username))) { document.getElementById(&quot;username&quot;).value=&quot;&quot;; alert(&quot;用户名输入不符合规范，请重新输入&quot;); } } document.getElementById(&quot;checkPWD&quot;).onchange=function() { var password1=document.getElementById(&quot;password&quot;).value; var password2=document.getElementById(&quot;checkPWD&quot;).value; if(!(password1==password2)) { document.getElementById(&quot;password&quot;).value=&quot;&quot;; document.getElementById(&quot;checkPWD&quot;).value=&quot;&quot;; alert(&quot;两次输入密码不一致请重新输入&quot;); } } document.getElementById(&quot;phone&quot;).onchange=function() { var phone=document.getElementById(&quot;phone&quot;).value; var regex=/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$/; if(!(regex.test(phone))) { document.getElementById(&quot;phone&quot;).value=&quot;&quot;; alert(&quot;手机号输入格式错误&quot;); } } document.getElementById(&quot;email&quot;).onchange=function() { var email=document.getElementById(&quot;email&quot;).value; var regex=/^([0-9A-Za-z\-_\.]+)@([0-9a-z]+\.[a-z]{2,3}(\.[a-z]{2})?)$/ if(!(regex.test(email))) { document.getElementById(&quot;email&quot;).value=&quot;&quot;; alert(&quot;邮箱格式错误&quot;); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;3.图书管理页面 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书后台管理系统&lt;/title&gt; &lt;/head&gt; &lt;frameset rows=&quot;20%,*&quot;&gt; &lt;frame src=&quot;./top.jsp&quot;&gt;&lt;/frame&gt; &lt;frameset cols=&quot;10%,*&quot;&gt; &lt;frame src=&quot;./left.html&quot;&gt;&lt;/frame&gt; &lt;frame name=&quot;main&quot;&gt;&lt;/frame&gt; &lt;/frameset&gt; &lt;/frameset&gt; &lt;/html&gt;4.左边的功能框界面left.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书后台管理&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;a href=&quot;./catgory.jsp&quot; target=&quot;main&quot;&gt;分类添加&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;./addBook.jsp&quot; target=&quot;main&quot;&gt;图书添加&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;./showBooks.jsp&quot; target=&quot;main&quot;&gt;图书查询&lt;/a&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;5.上边展示页面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% String name=(String)session.getAttribute(&quot;username&quot;);%&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt; 图书后台管理系统&lt;span style=&quot;font-size:12px&quot;&gt;您好，&lt;%=name %&gt;&lt;/span&gt; &lt;/h1&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;6.添加图书类界面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书分类添加&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;图书分类添加&lt;/h1&gt; &lt;form action=&quot;./CatgoryServlet&quot; method=&quot;post&quot;&gt; &lt;table width=&quot;400px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;分类ID&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;名&amp;nbsp;字&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;catgoryName&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;描&amp;nbsp;述&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;description&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;7.添加图书界面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;%@ page import=&quot;bookclass.LibDaoImpl&quot; %&gt; &lt;%@ page import=&quot;java.util.*&quot; %&gt; &lt;%@page import=&quot;java.util.Map&quot;%&gt; &lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;%LibDaoImpl dao=new LibDaoImpl(); List&lt;Map&lt;String,Object&gt;&gt; list=new ArrayList(); list=dao.getcatgorylist(); request.setAttribute(&quot;list&quot;,list); %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书添加&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;图书添加&lt;/h1&gt; &lt;form action=&quot;./AddBookServlet&quot; method=&quot;post&quot;&gt; &lt;table width=&quot;400px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;图书ID&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot; placeholder=&quot;请输入数字&quot; pattern=&quot;\d+&quot; required=&quot;required&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;图书名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;图书分类&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;catgoryName&quot;&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;c&quot;&gt; &lt;option value=&quot;${c.catgoryName}&quot;&gt;&amp;nbsp;&amp;nbsp;${c.catgoryName}&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; placeholder=&quot;请输入价格&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;描述&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;description&quot; placeholder=&quot;请输入描述信息&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;text-align:center&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;8.书籍展示页面 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@page import=&quot;bookclass.LibDaoImpl&quot;%&gt; &lt;%@page import=&quot;bookclass.Book&quot;%&gt; &lt;%@page import=&quot; java.util.List&quot;%&gt; &lt;%@page import=&quot; java.util.ArrayList&quot;%&gt; &lt;%@page import=&quot;java.util.Map&quot;%&gt; &lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;% LibDaoImpl dao=new LibDaoImpl(); List&lt;Book&gt;list =dao.getBook(); request.setAttribute(&quot;booklist&quot;,list); %&gt; &lt;/script&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;图书查询&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;图书查询&lt;/h1&gt; &lt;p&gt; 图书ID：&lt;input type=&quot;text&quot; name=&quot;bookID&quot; id=&quot;bookId&quot;&gt; 图书名：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; id=&quot;bookName&quot;&gt; 分类：&lt;input type=&quot;text&quot; name=&quot;catgoryName&quot; id=&quot;catoryName&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;查询&quot; id=&quot;search&quot;&gt; &lt;/p&gt; &lt;hr&gt; &lt;table width=&quot;800px&quot; cellspacing=&quot;0px&quot; cellpadding=&quot;0px&quot; border=&quot;1px&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;分类&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;cont&quot;&gt; &lt;c:forEach items=&quot;${booklist}&quot; var=&quot;b&quot;&gt; &lt;tr&gt; &lt;td&gt;${b.getBookId()}&lt;/td&gt; &lt;td&gt;${b.getBookName()}&lt;/td&gt; &lt;td&gt;${b.getBookCatogry()}&lt;/td&gt; &lt;td&gt;${b.getBookPrice() }&lt;/td&gt; &lt;td&gt;${b.getBookDescription() }&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/center&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#search&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/book/SelectBookServlet&quot;, &quot;data&quot;:{bookID:$(&quot;#bookId&quot;).val(), bookName:$(&quot;#bookName&quot;).val(), catgoryName:$(&quot;#catoryName&quot;).val() }, &quot;type&quot;:&quot;post&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json){ var content=&quot;&quot;; for(var i=0;i&lt;json.length;i++){ content=content+&quot;&lt;tr&gt;&lt;td&gt;&quot;+json[i].bookId + &quot;&lt;/td&gt;&lt;td&gt;&quot;+json[i].bookName+ &quot;&lt;/td&gt;&lt;td&gt;&quot;+json[i].bookCatogry+ &quot;&lt;/td&gt;&lt;td&gt;&quot;+json[i].bookPrice+ &quot;&lt;/td&gt;&lt;td&gt;&quot;+json[i].bookDescription+ &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; $(&quot;#cont&gt;tr&quot;).remove(); } $(&quot;#cont&quot;).html(content); } }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;Book类 package bookclass; public class Book { private String bookId; private String bookName; private String bookCatogry; private String bookPrice; private String bookDescription; @Override public String toString() { return &quot;Book [bookId=&quot; + bookId + &quot;, bookName=&quot; + bookName + &quot;, bookCatogry=&quot; + bookCatogry + &quot;, bookPrice=&quot; + bookPrice + &quot;, bookDescription=&quot; + bookDescription + &quot;]&quot;; } public Book() { // TODO Auto-generated constructor stub } public String getBookId() { return bookId; } public void setBookId(String bookId) { this.bookId = bookId; } public String getBookName() { return bookName; } public void setBookName(String bookName) { this.bookName = bookName; } public String getBookCatogry() { return bookCatogry; } public void setBookCatogry(String bookCatogry) { this.bookCatogry = bookCatogry; } public String getBookPrice() { return bookPrice; } public void setBookPrice(String bookPrice) { this.bookPrice = bookPrice; } public String getBookDescription() { return bookDescription; } public void setBookDescription(String bookDescription) { this.bookDescription = bookDescription; } }User类 package bookclass; public class User { public User(String username, String password, String phone, String email) { super(); this.username = username; this.password = password; this.phone = phone; this.email = email; } private String username; private String password; private String phone; private String email; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } }操作类 package bookclass; import java.util.ArrayList; import java.util.List; import java.util.Map; public class LibDaoImpl { private static final List&lt;User&gt; userlist=new ArrayList&lt;&gt;(); private static final List&lt;Map &lt;String,Object&gt; &gt; catgorylist =new ArrayList&lt;&gt;(); private static final List&lt;Book&gt; booklist=new ArrayList&lt;&gt;(); public void addUser(User user)//添加用户 { userlist.add(user); } public boolean isExitsUsername(String username)//判断该用户是否注册过 { for(User user:userlist) { if(user.getUsername().equals(username)) { return true; } } return false; } public boolean successLogin(String username,String password) { for(User user:userlist) { if(user.getUsername().equals(username)&amp;&amp;user.getPassword().equals(password)) { return true; } } return false; } public void addcatgorylist(Map &lt;String,Object&gt; map)//添加图书分类 { catgorylist.add(map); } public List&lt;Map &lt;String,Object&gt; &gt; getcatgorylist()//获取图书分类 { return catgorylist; } public void addBook(Book book) { booklist.add(book); } public List&lt;Book&gt; getBook() { return booklist; } public List&lt;Book&gt; findBookByCondition(String bookID,String bookCatgory,String bookName) { List&lt;Book&gt; rightbook=new ArrayList&lt;&gt;(); for(Book book:booklist) { if(book.getBookCatogry().equals(bookCatgory)||book.getBookName().equals(bookName)||book.getBookId().equals(bookID)) { rightbook.add(book); } } return rightbook; } }添加书的servlet package servlet; import bookclass.Book; import bookclass.LibDaoImpl; import java.io.IOException; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Servlet implementation class AddBookServlet */ @WebServlet(&quot;/AddBookServlet&quot;) public class AddBookServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public AddBookServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); String id=request.getParameter(&quot;id&quot;); String bookName=request.getParameter(&quot;bookName&quot;); String catgoryName=request.getParameter(&quot;catgoryName&quot;); String price=request.getParameter(&quot;price&quot;); String description=request.getParameter(&quot;description&quot;); Book book=new Book(); book.setBookCatogry( catgoryName); book.setBookDescription(description); book.setBookId(id); book.setBookName(bookName); book.setBookPrice(price); LibDaoImpl dao=new LibDaoImpl(); dao.addBook(book); response.sendRedirect(&quot;./showBooks.jsp&quot;); } }添加书类的servlet package servlet; import java.io.IOException; import java.util.HashMap; import java.util.Map; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import bookclass.LibDaoImpl; /** * Servlet implementation class CatgoryServlet */ @WebServlet(&quot;/CatgoryServlet&quot;) public class CatgoryServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CatgoryServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); String id=request.getParameter(&quot;id&quot;); String catgoryName =request.getParameter(&quot;catgoryName&quot;); String description =request.getParameter(&quot;description&quot;); LibDaoImpl dao=new LibDaoImpl(); Map&lt;String,Object&gt;map=new HashMap&lt;&gt;(); map.put(&quot;id&quot;, id); map.put(&quot;catgoryName&quot;,catgoryName); map.put(&quot;description&quot;,description); dao.addcatgorylist(map); response.sendRedirect(&quot;./catgory.jsp&quot;); } }用户登陆servlet package servlet; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import bookclass.LibDaoImpl; /** * Servlet implementation class LoginServlet */ @WebServlet(&quot;/LoginServlet&quot;) public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public LoginServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub String username=request.getParameter(&quot;username&quot;); String password=request.getParameter(&quot;password&quot;); LibDaoImpl dao=new LibDaoImpl(); if(dao.isExitsUsername(username)) { if(dao.successLogin(username, password)) { request.getSession().setAttribute(&quot;username&quot;,username); response.sendRedirect(&quot;./server.html&quot;); } else { response.sendRedirect(&quot;./index.jsp?flag=1&quot;); } } else response.sendRedirect(&quot;./regist.jsp?flag=2&quot;); } }用户注册servlet package servlet; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import bookclass.LibDaoImpl; import bookclass.User; /** * Servlet implementation class RegistServlet */ @WebServlet(&quot;/RegistServlet&quot;) public class RegistServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public RegistServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub request.setCharacterEncoding(&quot;UTF-8&quot;); String username=request.getParameter(&quot;username&quot;); String password=request.getParameter(&quot;password&quot;); String phone=request.getParameter(&quot;phone&quot;); String email=request.getParameter(&quot;email&quot;); LibDaoImpl dao =new LibDaoImpl(); if(dao.isExitsUsername(username))//为真表明已经注册过 { response.sendRedirect(&quot;./index.jsp?flag=3&quot;); } else { User user=new User(username,password,phone,email); dao.addUser(user); response.sendRedirect(&quot;./index.jsp&quot;); } } }查询书籍servlet package servlet; import java.io.IOException; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; import bookclass.Book; import bookclass.LibDaoImpl; /** * Servlet implementation class SelectBookServlet */ @WebServlet(&quot;/SelectBookServlet&quot;) public class SelectBookServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public SelectBookServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub response.setContentType(&quot;text/html;charset=utf-8&quot;); String bookID=request.getParameter(&quot;bookID&quot;); String bookName=request.getParameter(&quot;bookName&quot;); String catgoryName=request.getParameter(&quot;catgoryName&quot;); LibDaoImpl dao=new LibDaoImpl(); List&lt;Book&gt; abook=dao.findBookByCondition(bookID, catgoryName, bookName); String json=JSON.toJSONString(abook); response.getWriter().println(json); } }两个过滤类1.解决中文乱码的过滤类 package filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; /** * Servlet Filter implementation class CharacterEncodingFilter */ @WebFilter(&quot;/CharacterEncodingFilter&quot;) public class CharacterEncodingFilter implements Filter { private FilterConfig config; /** * Default constructor. */ public CharacterEncodingFilter() { // TODO Auto-generated constructor stub } /** * @see Filter#destroy() */ public void destroy() { // TODO Auto-generated method stub } /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(config.getInitParameter(&quot;charset&quot;)); chain.doFilter(request, response); } public void init(FilterConfig config) throws ServletException { this.config = config; } public FilterConfig getConfig() { return config; } public void setConfig(FilterConfig config) { this.config = config; } }2.解决用户没登陆就进入界面的过滤类 package filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * Servlet Filter implementation class LoginFilter */ @WebFilter(&quot;/LoginFilter&quot;) public class LoginFilter implements Filter { /** * Default constructor. */ public LoginFilter() { // TODO Auto-generated constructor stub } /** * @see Filter#destroy() */ public void destroy() { // TODO Auto-generated method stub } /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest hrequest=(HttpServletRequest)request; HttpServletResponse hresponse=(HttpServletResponse)response; String name=(String)hrequest.getSession().getAttribute(&quot;username&quot;); System.out.println(name); if(name==null||name.length()==0) { hresponse.sendRedirect(hrequest.getContextPath()+&quot;/index.jsp?flag=2&quot;); return ; } else { chain.doFilter(request, response); return; } } /** * @see Filter#init(FilterConfig) */ public void init(FilterConfig fConfig) throws ServletException { // TODO Auto-generated method stub } }3.xml配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;book&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;loginFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.LoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;loginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/server.html&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;charset&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>图书馆管理项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F19%2F%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123输出: 321示例 2: 输入: -123输出: -321示例 3: 输入: 120输出: 21注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 思路： 这道题翻转比较简单，利用x%10求剩余整数的最后一位。通过循环实现将最后一位*10变成第一位。倒数第二位变成第二位等等依次翻转。每次x=x/10； 这道题关键在于处理溢出。由计算我们可知：2^31-1=2147483647,-2^31=-2147483648 所以当我们反转的时候一定要注意得数在这两个范围内。那么我们怎么判断翻转之后在这个范围内。我们通过观察发现两个数只有最后一位不同。我们可以提取要翻转的数的第一位出来，把除了第一位剩下位翻转结果求出来，如果是正数。那么他应该小于(2^31-1)/10; 如果是负数那么它应该大于(2^31)/10，如果相等的话。比较第一位也就是翻转后的最后一位。正数的话一定小于7，负数的话大于-8； 否则返回零。 代码class Solution { public int reverse(int x) { int res=0; int r; while(x!=0) { r=x%10; x=x/10; if(res&gt;Integer.MAX_VALUE/10||res==Integer.MAX_VALUE/10&amp;&amp;r&gt;7)return 0; if(res&lt;Integer.MIN_VALUE/10||res==Integer.MIN_VALUE/10&amp;&amp;r&lt;-8)return 0; res=res*10+r; } return res; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小张今天leetcode了吗]]></title>
    <url>%2F2019%2F09%2F19%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[无重复字符的最长字串 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。思路1：刚开始想的是动态规划，先定义一个数组dp[i]用来记录以字符串中每个字符为结尾的无重复字符的最大长度。每次求解过程中取最优。 在求以每个字符为结尾的无重复字符的最大长度时，判断已经比较过的字符串中有没有当前的字符，如果存在： 就求该字符和与它相同的字符最后一次出现的位置的差值d如果d&lt;=d[i-1]那么就说明和它相同的字符出现在上一个字符为结尾的最长无重复子串中，那么d[i]=d;也就是将和它重复的那个字符以及它之前的所有字符全都舍去。从下一个和它不同的字符开始计算最长字串长度 但是如果d&gt;d[i-1]证明它不在上一个字符的最长字串中,它的存在给它上一个字符的dp[i-1]都无影响，对该字符更没有影响，直接在上一个字符的dp[i-1]+1即可，d[i]=d[i-1]+1; 如果不存在就直接d[i]=d[i]+1 代码如下class Solution { public int lengthOfLongestSubstring(String s) { int[] dp=new int[s.length()]; int res=1; if(s.length()==0) return 0; dp[0]=1; for(int i=1;i&lt;s.length();i++) { char c=s.charAt(i);//获取此时的字符 if(s.contains(c+&quot;&quot;)) { int index=s.lastIndexOf(c,i-1);//找到该字符在i-1个字符之前最后一次出现的位置 int d=i-index; if(d&lt;=dp[i-1]) { dp[i]=d; } else if(d&gt;dp[i-1]) { dp[i]=dp[i-1]+1; } } else { dp[i]=dp[i-1]+1; } res=Math.max(res,dp[i]);//每次更新res的值。 } return res; } }思路2：还有一种是滑动窗口的办法，这个是处理字符串很有效的很常见的办法。 具体思路：我们设置一个窗口不断更新他的左右边界索引，确保此时窗口里面的长度是以该字符结尾的最长字串长度。每次更新窗口的时候，也要更新记录最长字串长度的变量值。 首先我们可以用set来构造这样的一个窗口。遍历整个字符串。每次遇到一个新字符的时候，看看窗口中有没有该字符，如果没有直接加入这个窗口。然后更新右边界的索引值。如果在窗口中有该值，那为了让新值进入这个窗口，只能留下相同值后面的值了，这样保证不重复。这个思路比上一个思路优化在，我们只需要判断窗口有没有该字符就行。而不用判断之前的整个子串有没有该字符。 代码： class Solution { public int lengthOfLongestSubstring(String s) { Set&lt;Character&gt;set=new HashSet&lt;&gt;(); int j=0; int i=0; int len=s.length(); char[] ss=s.toCharArray(); int res=0; while(i&lt;len&amp;&amp;j&lt;len) { if((!set.contains(ss[j]))) { set.add(ss[j++]); res=Math.max(res,j-i); } else { set.remove(ss[i++]); } } return res; } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听器项目（用户登录控制）]]></title>
    <url>%2F2019%2F09%2F15%2F%E7%9B%91%E5%90%AC%E5%99%A8%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[要求: 通过过滤器实现登陆控制，未登陆用户不能访问系统首页 用户登陆，将登录名存储到session中 登陆监听器监听session属性中登陆值属性变化 若登陆用户用户名已登陆到系统，清除前次登陆信息 首先写登陆页面index.jsp，构造登陆页面的表单，用户输入用户名和密码等 &lt;form action=&quot;login.jsp&quot; method=&quot;post&quot;&gt; &lt;h1&gt;系统登录&lt;/h1&gt; &lt;label&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;/label&gt; &lt;label&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;/label&gt; &lt;span&gt;&amp;nbsp;&lt;/span&gt; &lt;label&gt; &lt;input type=&quot;submit&quot; class=&quot;button&quot; value=&quot;登录&quot;/&gt; &lt;/label&gt; &lt;/form&gt;在xml中将index.jsp设成默认首页、 &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;因为表单提交到login.jsp中 所以我们要对login.jsp进行代码书写我们为了实现登陆控制：没有登陆的用户不可以进入主页。我们要在login.jsp中实现将用户的姓名和密码放到session中。以便在后续过滤器的过滤。 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); session.setAttribute(&quot;loginUser&quot;, username);//登录完成，将登录用户名存储至session对象 response.sendRedirect(request.getContextPath()+&quot;/main.jsp&quot;); %&gt;此时跳转到main.jsp中 也就是我们登陆成功后即将要访问的首页 那么现在我们就要解决一个很关键的问题。如果我没有输入用户名和密码我可以进到这个首页吗？答案当然是否定的，所以我们就需要对main.jsp进行过滤。 我们如何进行过滤？我们可以获取我们在login中session中存储的属性获取用户姓名如果姓名字符串长度为0或者为空那么我们可以得出用户并没有输入有效得用户名，他们是没有进入首页得资格的。此时我们就要进行过滤操作，将页面直接跳转到登陆页面并进行标记，告诉用户要先进行登陆 代码以及书写步骤： 创建一个类实现过滤器接口。创建对象 获取session中得属性值，判断是否为null或者长度为0，如果不是，放行。chain.doFilter方法告诉浏览器过滤结束放行。如果是，就回到登录页民重新登陆具体代码： package com.imooc.filter; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * * @author lv * */ public class SessionFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest hrequest = (HttpServletRequest)request; HttpServletResponse hresponse = (HttpServletResponse)response; String loginUser = (String)hrequest.getSession().getAttribute(&quot;loginUser&quot;); if(loginUser==null||loginUser.length() == 0) { hresponse.sendRedirect(hrequest.getContextPath()+&quot;/index.jsp?flag=1&quot;); return; }else{ chain.doFilter(request, response); return; } } @Override public void init(FilterConfig arg0) throws ServletException { } }别忘了要在xml中注册过滤器 &lt;filter&gt; &lt;filter-name&gt;sessionFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.imooc.filter.SessionFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;sessionFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/main.jsp&lt;/url-pattern&gt;我们此时返回index.jsp中添加一句话。告诉用户重新登陆 &lt;script type=&quot;text/javascript&quot;&gt; var flag = &apos;&lt;%=flag %&gt;&apos;; if(&quot;1&quot;==flag){ alert(&quot;你尚未登陆，或者账号在异地登陆，请重新登陆！&quot;); } &lt;/script&gt;到现在我们就完成了第一个目标 实现了如果用户不登录就无法访问主页的功能，利用的是过滤器的相关知识。那么我们怎么判断该用户登陆过，怎么实现用户信息的存储，怎么实现对已经登陆的用户实现销毁呢我们此时要借助java中的单例模式 保证缓存中只有一个对象单例模式的要点：构造函数的私有化 我们首先建立私有化的构造函数，然后创建一个静态变量，保证只有一个该变量在创建一个共有的静态方法，返回静态变量，返回只有一个。HttpSession对象在创建后，都会有唯一的ID与其他session做标志区别但是不支持通过sessionId获取Session对象我们可以定义两份存储。第一个是存储sessionid和用户登陆名的映射关系第二个是 session和sessionid的映射关系 package com.imooc.cache; import java.util.HashMap; import java.util.Map; import javax.servlet.http.HttpSession; /** 单例模式 * @author lv * */ public class LoginCache { private static LoginCache instance = new LoginCache(); //登陆名与会话id值 private Map&lt;String,String&gt; loginUserSession = new HashMap&lt;String,String&gt;(); private Map&lt;String,HttpSession&gt; loginSession = new HashMap&lt;String,HttpSession&gt;(); //sessionid 和session本身 //通过用户名获得sessionId 通过sessionid 获得对应的session private LoginCache(){ } public static LoginCache getInstance(){//获取实例对象 return instance; } /** * * @param username * @return */ public String getSessionIdByUsername(String username){//sessionid return loginUserSession.get(username); } /** * * @param sessionId * @return */ public HttpSession getSessionBySessionId(String sessionId){//session return loginSession.get(sessionId); } /** * * @param username * @param sessionId */ public void setSessionIdByUserName(String username,String sessionId){//存储操作 loginUserSession.put(username, sessionId); } /** * @param sessionId * @param session */ public void setSessionBySessionId(String sessionId,HttpSession session){//存储 loginSession.put(sessionId, session); } }存储完了下一步就是对每个登陆的对象进行判断看是否之前登陆过此时就要用到监听器的知识。具体用何种监听器呢。每次用户登陆时都要创建一个session属性，所以我们可以使用HttpSessionAttribute Listener 来监听实例对象中属性的创建 创建一个类实现 HttpSessionAttributeListener接口然后在 attributeAdded(HttpSessionBindingEvent hsbe)方法中获取属性名，属性值，再获取当前的session和sessionid 在之前存储用户信息的缓冲区中根据用户名看是否能获取sessionid，如果获取到了证明用户已经登陆，此时要清除旧用户的登陆信息session.invalidate();该方法可以实现注销操作此时再将新用户的 用户名 sessionid session 他们三互相的映射关系存储到相应的集合中，完成用户的新登陆 package com.imooc.listener; import javax.servlet.http.HttpSession; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionBindingEvent; import com.imooc.cache.LoginCache; /** * * @author lv * */ public class LoginSessionListener implements HttpSessionAttributeListener { private static final String LOGIN_USER=&quot;loginUser&quot;; @Override public void attributeAdded(HttpSessionBindingEvent hsbe) { String attrName = hsbe.getName(); if(LOGIN_USER.equals(attrName)){ String attrVal = (String)hsbe.getValue(); HttpSession session = hsbe.getSession(); String sessionId = session.getId(); String sessionId2 = LoginCache.getInstance().getSessionIdByUsername(attrVal);//ֵ if(null == sessionId2){ }else{ HttpSession session2 = LoginCache.getInstance().getSessionBySessionId(sessionId2); session2.invalidate();//注销信息 } LoginCache.getInstance().setSessionIdByUserName(attrVal, sessionId); LoginCache.getInstance().setSessionBySessionId(sessionId, session); } } @Override public void attributeRemoved(HttpSessionBindingEvent arg0) { // TODO Auto-generated method stub } @Override public void attributeReplaced(HttpSessionBindingEvent arg0) { // TODO Auto-generated method stub } }到现在为止我们就完成了目标任务。该程序可以在主页main.jsp和index.jsp中添加css样式进行美化。更好的实现登陆页面功能。 要点 过滤器对目标网站进行过滤，保证了用户正确登陆之后才能进入main.jsp页面。 监听器对对象的添加属性动作进行监听。保证了session中只有一个用户]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>监听器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听器入门]]></title>
    <url>%2F2019%2F09%2F10%2F%E7%9B%91%E5%90%AC%E5%99%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.什么是监听器 监听器是一个专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。监听器其实就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。 ###2. java的事件监听机制1、事件监听涉及到三个组件：事件源、事件对象、事件监听器2、当事件源上发生某一个动作时，它会调用事件监听器的一个方法，并在调用该方法时把事件对象传递进去，开发人员在监听器中通过事件对象，就可以拿到事件源，从而对事件源进行操作。 3.Javaweb监听器 Servlet规范定义的一种特殊类 用于监听ServlertContext，HttpSession，ServletRequest等域对象的创建，销毁及其属性修改发生变化的事件 监听器可以在事件发生前后进行一些必要的处理操作 4.Javaweb监听器的分类 按监听对象分类 ServletContext对象监听器 HttpSession对象监听器 ServletRequest对象监听器 按监听事件分类 域对象自身的创建和销毁事件监听器 域对象中属性的创建，替换和消除事件 绑定到session中的某个对象的状态事件监听器 ####4.1按监听对象分类 4.1.1监听ServletContext域对象的创建和销毁ServletContextListener接口用于监听ServletContext对象的创建和销毁事件。实现了ServletContextListener接口的类都可以对ServletContext对象的创建和销毁进行监听。 当ServletContext对象被创建时，激发contextInitialized (ServletContextEvent sce)方法。 当ServletContext对象被销毁时，激发contextDestroyed(ServletContextEvent sce)方法。 ServletContext域对象创建和销毁时机：创建：服务器启动针对每一个Web应用创建ServletContext销毁：服务器关闭前先关闭代表每一个web应用的ServletContext 可以在web.xml中初始化参数比如数据库的连接/程序名称/版本号 初始化之后可以通过ContextInitialized方法读取初始化参数 实例：1.首先创建监听器接口实现类 2.然后在xml中注册监听器和配置初始化参数 java类实现ServletContextListener接口： import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; public class MyServletContextListener implements ServletContextListener { @Override public void contextDestroyed(ServletContextEvent sce) { // TODO Auto-generated method stub String appName=(String)sce.getServletContext().getAttribute(&quot;app_name&quot;); String version=(String)sce.getServletContext().getAttribute(&quot;version&quot;); System.out.println(&quot;destory:&quot;+appName +&quot;.&quot;+version); } @Override public void contextInitialized(ServletContextEvent sce) { String appName=sce.getServletContext().getInitParameter(&quot;app_name&quot;); String version=sce.getServletContext().getInitParameter(&quot;version&quot;); sce.getServletContext().setAttribute(&quot;app_name&quot;, appName); sce.getServletContext().setAttribute(&quot;version&quot;, version); System.out.println(&quot;init:&quot;+appName+&quot;,&quot;+version); } }XML配置： &lt;context-param&gt; &lt;param-name&gt;app_name&lt;/param-name&gt; &lt;param-value&gt;Listener Web&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;version&lt;/param-name&gt; &lt;param-value&gt;1.0&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;listener.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt;4.1.2监听HttpSession域对象的创建和销毁 HttpSessionListener 接口用于监听HttpSession对象的创建和销毁 创建一个Session时，激发sessionCreated (HttpSessionEvent se) 方法 销毁一个Session时，激发sessionDestroyed (HttpSessionEvent se) 方法。 当用于第一次通过浏览器与服务器进行交互的时候，我们的服务器就会创建一个HttpSession对象这个对象就存储着一个对象的专有信息比如用户的登陆名 登陆时间 权限 HttpSession对象相当于一个用户，当创建一个对象就意味着多了一个用户访问销毁要给对象，就相当于一个用户离开 实例：java类实现 HttpSessionListener接口： import java.util.Date; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; public class MyHttpSessionListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent hse) {//创建 // TODO Auto-generated method stub String sessionId=hse.getSession().getId(); Date createTime=new Date(hse.getSession().getCreationTime()); //getCreationTime() ，返回SESSION创建时间，从1970年1月1号凌晨开始算起，但其返回值是毫秒，一般需要使用前面的转换来获取具体日期和时间。 System.out.println(sessionId+&quot;，&quot;+createTime); } @Override public void sessionDestroyed(HttpSessionEvent hse) {//销毁 // TODO Auto-generated method stub String sessionId=hse.getSession().getId(); System.out.println(&quot;destory&quot;+sessionId); } }xml Session的默认时间设置是20分钟，即超过20分钟后,服务器会自动放弃Session信息在这里我们给session-timeout设置的事件为1分钟 也就是1分钟之后就自动销毁 &lt;listener&gt; &lt;listener-class&gt;listener.MyHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt; &lt;/session-config&gt;用户访问界面： 当我们访问jsp页面时，HttpSession对象就会创建，此时就可以在HttpSessionListener观察到HttpSession对象的创建过程了 4.1.3监听ServletRequest域对象的创建和销毁ServletRequestListener接口用于监听ServletRequest 对象的创建和销毁 Request对象被创建时，监听器的requestInitialized(ServletRequestEvent sre)方法将会被调用 Request对象被销毁时，监听器的requestDestroyed(ServletRequestEvent sre)方法将会被调用 ServletRequest域对象创建和销毁时机： 创建：用户每一次访问都会创建request对象 销毁：当前访问结束，request对象就会销毁 请求完成之后生命周期结束，只要对资源服务器有一个请求就会调用监听器 实例import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; import javax.servlet.http.HttpServletRequest; public class MyServletRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { // TODO Auto-generated method stub System.out.println(&quot;destroy&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { // TODO Auto-generated method stub HttpServletRequest request=(HttpServletRequest)sre.getServletRequest();//这里主要是http请求对象 对获得的事件需要转型 String path=request.getRequestURI();//获取路径 String par=request.getParameter(&quot;par&quot;);//获取请求参数 System.out.println(path+&quot;.&quot;+par); } }页面中写一个超链接对网页进行请求创建一个ServletRequest &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;lable&gt; &lt;span&gt;ServletRequestListener测试&lt;/span&gt; &lt;a href=&quot;servlet_request.jsp?par=request_par&quot;target=&quot;_blank&quot;&gt;初始化&lt;/a&gt; &lt;/lable&gt; &lt;/body&gt; &lt;/html&gt;xml中注册监听器 &lt;listener&gt; &lt;listener-class&gt;listener.MyServletRequestListener&lt;/listener-class&gt; &lt;/listener&gt;4.2 按监听事件分类4.2.1域对象中属性的创建，替换和消除事件监听器域对象中属性的变更的事件监听器就是用来监听 ServletContext, HttpSession, HttpServletRequest 这三个对象中的属性变更信息事件的监听器。 ServletContext——ServletContextAttributeListener HttpSession——HttpSessionAttributeListener ServletRequest——ServletRequestAttributeListener 对每个监听器都有共同的方法,只是接受的参数类型不同。:attributeAdded 属性增加,attributeReplaced 属性替换，attributeRemoved 属性移除 attributeAdded 方法 当向被监听对象中增加一个属性时，web容器就调用事件监听器的attributeAdded方法进行响应这个方法接收一个事件类型的参数，监听器可以通过这个参数来获得正在增加属性的域对象和被保存到域中的属性对象 各个域属性监听器中的完整语法定义为： public void attributeAdded(ServletContextAttributeEvent scae) public void attributeReplaced(HttpSessionBindingEvent hsbe) public void attributeRmoved(ServletRequestAttributeEvent srae) attributeRemoved 方法 当删除被监听对象中的一个属性时，web容器调用事件监听器的attributeRemoved方法进行响应 各个域属性监听器中的完整语法定义为： public void attributeRemoved(ServletContextAttributeEvent scae) public void attributeRemoved (HttpSessionBindingEvent hsbe) public void attributeRemoved (ServletRequestAttributeEvent srae) attributeReplaced 方法 当监听器的域对象中的某个属性被替换时，web容器调用事件监听器的attributeReplaced方法进行响应各个域属性监听器中的完整语法定义为： public void attributeReplaced(ServletContextAttributeEvent scae) public void attributeReplaced (HttpSessionBindingEvent hsbe) public void attributeReplaced (ServletRequestAttributeEvent srae) 以ServletContextAttributeListener为例,其他的两个监听器同理：在java类中继承ServletContextAttributeListener接口 import javax.servlet.ServletContextAttributeEvent; import javax.servlet.ServletContextAttributeListener; public class MyServletContextAttribute implements ServletContextAttributeListener { @Override public void attributeAdded(ServletContextAttributeEvent scae) { // TODO Auto-generated method stub System.out.println(scae.getName()+&quot;,&quot;+scae.getValue()); } @Override public void attributeRemoved(ServletContextAttributeEvent scae) { // TODO Auto-generated method stub System.out.println(&quot;remove&quot;+scae.getName()+&quot;,&quot;+scae.getValue()); } @Override public void attributeReplaced(ServletContextAttributeEvent scae) { // TODO Auto-generated method stub System.out.println(scae.getName()+&quot;,&quot;+scae.getValue()); } }测试页面jsp中添加属性 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;% application.setAttribute(&quot;servletcontextPar&quot;,&quot;servletcontext_par&quot;);//添加属性 application.setAttribute(&quot;servletcontextPar&quot;,&quot;servletcontext_par1&quot;);//替换属性 application.removeAttribute(&quot;servletcontextPar&quot;);//移除属性 %&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;dffd&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;xml &lt;listener&gt; &lt;description&gt;MyServletContextAttributeListener监听器&lt;/description&gt; &lt;listener-class&gt;listener.MyServletContextAttribute&lt;listener-class&gt; &lt;/listener&gt;5.绑定到session中的某个对象的状态事件监听器Servlet 规范中定义了两个特殊的监听器接口”HttpSessionBindingListener和HttpSessionActivationListener”来帮助JavaBean 对象了解自己在Session域中的这些状态： ，实现这两个接口的类不需要 web.xml 文件中进行注册。 用户登陆就注册session,用户退出就解绑session valueBound（HttpSessionBindingEvent event）当监听器对象绑定至Http会话调用 valueUnbound(HttpSessionBindingEvent event) 当监听器对象从HTTP会话内修改移除或会话销毁时调用 实现了HttpSessionBindingListener接口的JavaBean对象可以感知自己被绑定到Session中和 Session中删除的事件. 当对象被绑定到HttpSession对象中时，web服务器调用该对象的void valueBound(HttpSessionBindingEvent event)方法. 当对象从HttpSession对象中解除绑定时，web服务器调用该对象的void valueUnbound(HttpSessionBindingEvent event)方法. 继承HttpSessionBindingListener的java package com.imooc.listener; import javax.servlet.http.HttpSessionBindingEvent; import javax.servlet.http.HttpSessionBindingListener; public class User implements HttpSessionBindingListener { private String username; private String password; @Override public void valueBound(HttpSessionBindingEvent hsbe) { // TODO Auto-generated method stub String name=hsbe.getName();//返回发生绑定对象的名字 System.out.println(&quot;value bound name:&quot;+name); } @Override public void valueUnbound(HttpSessionBindingEvent hsbe) { // TODO Auto-generated method stub String name=hsbe.getName();//返回取消绑定的对象的名字 System.out.println(&quot;value unbound name:&quot;+name); } }页面设置 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;lable&gt; &lt;span&gt;测试&lt;/span&gt; &lt;a href=&quot;bound.jsp&quot;target=&quot;_blank&quot;&gt;绑定&lt;/a&gt; &lt;a href=&quot;unbound.jsp&quot;target=&quot;_blank&quot;&gt;解除绑定&lt;/a&gt; &lt;/lable&gt; &lt;/body&gt; &lt;/html&gt;bound.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;% session.setAttribute(&quot;user&quot;,new listener.User());//绑定 //session.removeAttribute(&quot;user&quot;);//解除绑定 %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;bound&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>监听器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤器入门]]></title>
    <url>%2F2019%2F09%2F10%2F%E8%BF%87%E6%BB%A4%E5%99%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.什么是过滤器Filter Filter就是英文的过滤器，WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 2.如何实现Filter2.1创建的java类实现Filter接口. Filter接口中有三个方法： default void init(FilterConfig filterConfig) void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) default void destroy() 其中init初始化和销毁destroy是默认实现的，我们无需重写 doFilter 是一个核心方法，我们必须要实现。 2.2关于doFilter方法：doFilter方法是filter接口中的核心方法.一旦创建完该过滤器的实例之后，会执行dofilter方法,主要有三个参数.其中，参数 request 和 response 为 Web 容器或 Filter 链中上一个 Filter 传递过来的请求和响应对象；参数 chain 为代表当前 Filter 链的对象。 2.3.在web.xml文件中对filter类进行注册。并设置它所要拦截的资源&lt;!--配置过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;//过滤器名字 &lt;filter-class&gt;filter.CharacterEncoding&lt;/filter-class&gt;//过滤器类 &lt;/filter&gt; &lt;!--映射过滤器--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;实例：/** * 字符集编码过滤器 */ import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class CharacterEncodingFilter implements Filter { @Override public void destroy() { System.out.println(&quot;----过滤器销毁----&quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(&quot;UTF-8&quot;); // System.out.println(&quot;characterEncodingFilter 请求预 处理&quot;);//测试过滤器（链）工作流程使用 chain.doFilter(request, response);//让目标资源执行放行 // System.out.println(&quot;characterEncodingFilter 响应后处理&quot;);//测试过滤器（链）工作流程使用 } @Override public void init(FilterConfig config) throws ServletException { System.out.println(&quot;----过滤器初始化----&quot;); } } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 过滤器注册--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.CharacterEncoding&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt;2.4关于过滤链：chain.doFilter(request, response) 在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。Web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。 3.Fliter的生命周期 web应用程序启动时，web服务器创建Filter的实例对象。以及对象的初始化 当请求访问与过滤器关联的Web资源时，过滤器拦截请求，完成指定的功能 Filter对象创建会驻留在内存，在web应用移除或者服务器停止的时候才会销毁 过滤器的创建和销毁由服务器负责。 ###4. FilterConfig接口 用户在配置filter时，可以使用为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得： String getFilterName()：得到filter的名称。 String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。 public ServletContext getServletContext()：返回Servlet上下文对象的引用。 实例:import java.io.IOException; import java.util.Enumeration; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class FilterDemo02 implements Filter { /* 过滤器初始化 * @see javax.servlet.Filter#init(javax.servlet.FilterConfig) */ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(&quot;----过滤器初始化----&quot;); //得到过滤器的名字 String filterName = filterConfig.getFilterName(); //得到在web.xml文件中配置的初始化参数 String initParam1 = filterConfig.getInitParameter(&quot;name&quot;); String initParam2 = filterConfig.getInitParameter(&quot;like&quot;); //返回过滤器的所有初始化参数的名字的枚举集合。 Enumeration&lt;String&gt; initParameterNames = filterConfig.getInitParameterNames(); System.out.println(filterName); System.out.println(initParam1); System.out.println(initParam2); while (initParameterNames.hasMoreElements()) { String paramName = (String) initParameterNames.nextElement(); System.out.println(paramName); } } @Override public void doFilter(ServletRequest request, ServletResponse response, System.out.println(&quot;FilterDemo02执行前！！！&quot;); chain.doFilter(request, response); //让目标资源执行，放行 System.out.println(&quot;FilterDemo02执行后！！！&quot;); } @Override public void destroy() { System.out.println(&quot;----过滤器销毁----&quot;); } }xml 配置： &lt;filter&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;!--配置FilterDemo02过滤器的初始化参数--&gt; &lt;init-param&gt; &lt;description&gt;配置FilterDemo02过滤器的初始化参数&lt;/description&gt; &lt;param-name&gt;name &lt;/param-name&gt; &lt;param-value&gt;gacl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;description&gt;配置FilterDemo02过滤器的初始化参数&lt;/description&gt; &lt;param-name&gt;like&lt;/param-name&gt; &lt;param-value&gt;java&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;5.Fileter 的部署： 注册Filter 映射Filter 注册Filter：&lt;filter&gt; &lt;description&gt;FilterDemo02过滤器&lt;/description&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;filter-class&gt;me.gacl.web.filter.FilterDemo02&lt;/filter-class&gt; &lt;!--配置FilterDemo02过滤器的初始化参数--&gt; &lt;init-param&gt; &lt;description&gt;配置FilterDemo02过滤器的初始化参数&lt;/description&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;gacl&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;description&gt;配置FilterDemo02过滤器的初始化参数&lt;/description&gt; &lt;param-name&gt;like&lt;/param-name&gt; &lt;param-value&gt;java&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;description&gt; 用于添加描述信息，该元素的内容可为空，&lt;description&gt;可以不配置。 用于为过滤器指定一个名字，该元素的内容不能为空。 元素用于指定过滤器的完整的限定类名。 元素用于为过滤器指定初始化参数，它的子元素指定参数的名字，指定参数的值。在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。如果过滤器不需要指定初始化参数，那么元素可以不配置。 映射Filter &lt;!--映射过滤器--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo02&lt;/filter-name&gt; &lt;!--“/*”表示拦截所有的请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径 子元素用于设置filter的注册名称。该值必须是在元素中声明过的过滤器的名字 设置 filter 所拦截的请求路径(过滤器关联的URL样式) 指定过滤器所拦截的Servlet名称。 指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个 子元素用来指定 Filter 对资源的多种调用方式进行拦截。 6.java的4种过滤器： REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。 配置如下： &lt;filter-mapping&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-两数之和]]></title>
    <url>%2F2019%2F09%2F08%2Fleetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[开始刷leetcode啦！加油加油！ 题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思想刚开始想的特别简单就是在给定数组中进行遍历，两层for循环看看两个数相加是否可以==target，如果有的话直接返回当时的ij值 代码如下public class Solution { public int[] twoSum(int[] nums, int target) { int[] arr=new int[2]; for(int i=0;i&lt;nums.length-1;i++){ for(int j=i+1;j&lt;nums.length;j++){ if(nums[i]+nums[j]==target){ return new int[]{i,j}; } } } return arr; } }当时显示的是：用时54ms 内存消耗38.4MB； 后来又看到了大佬的代码 这道题的标签时数组和哈希表我当时并没有想到可以用hashMap;看完大佬的代码才反应过来这样只需要一层循环，时间肯定可以减少不少 思路：先建一个map集合。然后遍历整个nums数组，在该组数中先看每一个nums[i]的值，如果target-nums[i]存在，就证明这两个数相加等于target.如果不存在就直接保存num[i]和对应的索引值i，这点用的比较巧妙。一边找一边存，每次寻找只需要寻找之前遍历过的nums[]里面的值,看是否有等于target-nums[i]即可。 代码如下：public class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++){ Integer index=map.get(target-nums[i]); if(index==null){ map.put(nums[i],i); }else{ return new int[]{i,index}; } } return new int[]{0,0}; } }此时显示执行用时9ms，内存消耗39Mz，时间上大大减少了。代码算法优化简直太重要啦]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>-leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是正则表达式 正则表达式是检查，匹配字符串的表达式 正则表达式是描述规则，主流语言都有很好的支持 字符串校验，查找与替换是正则表达式主要使用场景 字符范围的匹配 A 精准匹配单个字符 x|y 允许出2个字符 [xyz]字符集和，允许出现集合内任意单个字符 [a-z] [A-z] [0-9] 字符范围 [^xyz] [^0-9] 集合中字符不允许出现 ^ 这个符号相当于取反 也就是不能有这个符号后面的字符 练习：精准匹配字符串“hallo”或者“hello” h[ae]llo 请匹配数字范围（0570-0579) [0570-0579]或者 057[0-9] 单选题只允许输入ABCD其中一项[ABCD] [A-D] 元字符 所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符(即位于元字符前面的字符)在目标对象中的出现模式元字符是一个或一组代替一个或多个字符的字符。 \d 匹配任意单个数字 \D 匹配\d规则之外的任意单个字符 \w 匹配任意单个字母，数字，下划线 \W 匹配\w之外的任意单个字符 \s 匹配单个空格 \n 匹配单个换行符 . 匹配任意单个字符(换行符除外） \. 特殊字符，只匹配 练习 匹配数字3213.383219 如果写成\d\d\d\d.\d\d\d\d\d\d那么当写成1234A456878 也同样可以匹配上 因为.代表了任意字符所以应该\d\d\d\d.\d\d\d\d\d\d 加一个\令它原义输出 匹配杭州与宁波座机号码（0571|0574-XXXXXXXX) 057[14]-\d\d\d\d\d\d\d\d 请匹配18位身份证号 因为身份证第一位不能079。所以答案[1234568]\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d[0-9xX] 多次重复匹配 A{3} 精准的N次匹配 （正确：AAA；错误：AA） A{3,} 最少出现N次 （正确：AAA；错误：AA） \d{3,5} 出现最大次数与最小次数，所以最大5，最小3 （正确：1234；错误：12） \d* 可以出现零次至无限次相当于{0，}（正确12345；） \d+ 最少出现一次，相当于{1，} （正确：12；错误： ） \d? 至多出现一次相当于{0，1} （正确：1；错误：22） 练习 验证短信验证码（6位数字) \d{6} 请匹配全国座机号(区号3或者4位-电话号7或者8位) \d{3,4}-\d{7,8} 匹配英文姓名 [A-Z][a-z]+\s[A-Z][a-z]* 定位匹配 ^A.* 头匹配 （正确：ABC；错误：CBA） .*A$ 尾匹配 （正确：CBA；错误：ABC） ^A.*A$ 全字匹配 （正确：ACCCA;错误：ACCB） 贪婪模式与非贪婪模式 贪婪模式：在满足条件情况下尽可能多匹配 非贪婪模式：在满足条件情况下尽可能少匹配 举例：对于 11221111 这个字符串 如果表达式是 \d{6,8} 会匹配到11221111 但是如果是 \d{6,8}? 则会匹配到 112211 所以在正则表达时描述数量的地方后面加一个？ 即可变成非贪婪模式 练习&lt;a href=”www.baidu.com&quot;\&gt;百度&lt;/a&gt;&lt;a href=”www.sina.com&quot;\&gt;新浪&lt;/a&gt; 如果输入“.*”匹配结果：”www.baidu.com&quot;&gt;百度&lt;a href=”www.baidu.com&quot; “.*？” （？写在描述数量的后面）匹配结果： 2处匹配 “www.baidu.com&quot; “www.sina.com&quot; 表达式分组将子表达式进行包裹用小括号 练习匹配验证码(4或者6位) (^\d{4}$)|(^\d{6}$) 匹配车牌号（冀A-U888G) ^([冀黑粤晋][A-Z])-([A-Z0-9]{5})$ 匹配中文或英文姓名 (^[\u4e00-\u9fa5]{2,8}$)|(^[A-Z][a-z]+\s[A-Z][a-z]*$) javascript 表单的验证步骤： 先定义正则表达式 利用正则表达式的test()方法对要验证的字符串进行检查 如果匹配则返回true 如果不匹配则返回false 实例&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;#&quot; id=&quot;frmInfo&quot;&gt; &lt;div id=&quot;err&quot; style=&quot;color:red&quot;&gt; &lt;/div&gt; &lt;div&gt;姓名:&lt;input id=&quot;name&quot; name=&quot;name&quot;/\&gt;&lt;/div&gt; &lt;div&gt;身份证:&lt;input id=&quot;idno&quot; name=&quot;idno&quot;/\&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;submit&quot; &gt;&lt;/div&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;frmInfo&quot;).onsubmit=function() { //在JS中定义正则表达式对象只需要在/正则表达式/ var regex1=/^[\u4e00-\u9fa5]{2,8}$/; var regex2=/^[1234568]\d{16}[0-9Xx]$/; var name=document.getElementById(&quot;name&quot;).value; var idno=document.getElementById(&quot;idno&quot;).value; if(regex1.test(name)==false) { document.getElementById(&quot;err&quot;).innerHTML=&quot;无效姓名&quot;; return false; } else if(regex2.test(idno)==false) { document.getElementById(&quot;err&quot;).innerHTML=&quot;无效身份证&quot;; return false; } else { alert(&quot;正在提交&quot;); return true; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;java中web页面信息的提取网页信息 &lt;!DOCTYPEhtml&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;国际主要城市&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;国际主要城市&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;纽约NewYork&lt;/li&gt; &lt;li&gt;伦敦London&lt;/li&gt; &lt;li&gt;东京Tokyo&lt;/li&gt; &lt;li&gt;巴黎Paris&lt;/li&gt; &lt;li&gt;香港HongKong&lt;/li&gt; &lt;li&gt;新加坡Singapore&lt;/li&gt; &lt;li&gt;悉尼Sydney&lt;/li&gt; &lt;li&gt;米兰Milano&lt;/li&gt; &lt;li&gt;上海Shanghai&lt;/li&gt; &lt;li&gt;北京Beijing&lt;/li&gt; &lt;li&gt;马德里Madrid&lt;/li&gt; &lt;li&gt;莫斯科Moscow&lt;/li&gt; &lt;li&gt;首尔Seoul&lt;/li&gt; &lt;li&gt;曼谷Bangkok&lt;/li&gt; &lt;li&gt;多伦多Toronto&lt;/li&gt; &lt;li&gt;布鲁塞尔Brussels&lt;/li&gt; &lt;li&gt;芝加哥Chicago&lt;/li&gt; &lt;li&gt;吉隆坡KualaLumpur&lt;/li&gt; &lt;li&gt;孟买Mumbai&lt;/li&gt; &lt;li&gt;华沙Warsaw&lt;/li&gt; &lt;li&gt;圣保罗SaoPaulo&lt;/li&gt; &lt;li&gt;苏黎世Zurich&lt;/li&gt; &lt;li&gt;阿姆斯特丹Amsterdam&lt;/li&gt; &lt;li&gt;墨西哥城MexicoCity&lt;/li&gt; &lt;li&gt;雅加达Jakarta&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;下面的程序要从上面的网页中提取信息 首先我们要创建正则表达式对象： Pattern p=Pattern.compile(“&lt;li&gt;([\u4e00-\u9fa5]{2,})([A-Za-z]+)&lt;/li&gt;“);里面规定了正则表达式 定义一个匹配器对象，Matcher m=p.matcher(content) matcher方法返回一个匹配器对象 用m.find()方法判断是否可以匹配如果可以匹配则返回true ，否者返回false，对于那些成功匹配的可以输出出来 输出的时候 group(0)提取完整的字符串。如果正则表达式事先进行了分组，那么group(1)则输出第一个分组，group(2)则输出第二个分组，依次类推。 具体代码如下： import java.io.BufferedReader; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStreamReader; import java.io.UnsupportedEncodingException; import java.util.regex.Matcher; import java.util.regex.Pattern; public class Regex { public static void main(String[] args) throws IOException { StringBuilder content =new StringBuilder(); FileInputStream fis=new FileInputStream(&quot;E:\\eclipse\\regex\\WebContent\\NewFile.html&quot;); InputStreamReader isr=new InputStreamReader(fis,&quot;UTF-8&quot;);//转换流 BufferedReader BufferedReader =new BufferedReader (isr); String lineText=&quot;&quot;; while((lineText = BufferedReader.readLine())!=null) { //System.out.println(lineText); content.append(lineText); } BufferedReader.close(); Pattern p=Pattern.compile(&quot;&lt;li&gt;([\\u4e00-\\u9fa5]{2,})([A-Za-z]+)&lt;/li&gt;&quot;);//创建正则表达式对象 Matcher m=p.matcher(content);//matcher方法进行匹配返回一个匹配器对象 while(m.find())//在原始字符串查找如果匹配成功就可以提取出来 { //用group(0) 提取完整字符串 System.out.printf(m.group(1)); System.out.println(m.group(2)); } } }]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX项目-二级联动菜单的设置]]></title>
    <url>%2F2019%2F09%2F06%2FAJAX%E9%A1%B9%E7%9B%AE--%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8%E8%8F%9C%E5%8D%95%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.介绍二级联动的菜单在网页中很常见，通常是通过鼠标点一级菜单的相关内容之后二级菜单做出响应变化显示出一级菜单对应的子菜单。我这次是用AJAX的相关知识进行实现。 2.我的思路：1.首先我构造了一个类Channel目的就是为了为每个菜单添加名字和内容的两个属性。 2.在网页初初始化时候我们要对一级菜单进行显示，也就是向servlet中传递一个level=1的变量当服务器接收到level=1时 将一级菜单里面的内容通过json转为字符串传回到之前的html中通过javascript的AJax方法解析后，将内容放到对应html中的下拉表单中显示出来。 3.利用Ajax的动态更新，可以实时实现二级菜单的更新。因为每个一级菜单都对应一个二级菜单。所以在更新二级菜单时候可以根据一级菜单每个菜单栏的名字去寻找。那么此时我们需要一个事件，也就是发生什么事件之后对二级菜单进行更新，这个事件就是鼠标点击事件，根据鼠标点击一级菜单的哪个菜单项获取对应的菜单项的属性名，传到服务器上，服务器可以根据这个属性名来判断传送这个一级菜单对应哪个二级菜单，判断后用json方法转为字符串传到html中。再根据AJax方法解析后，将内容放到对应html中的下拉表单中显示出来，从而动态显示二级菜单。 package com.ajax; public class Channel { private String name; private String code; public Channel() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public Channel(String name, String code) { super(); this.name = name; this.code = code; }}sevlet代码： import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class ChannelServlet */ @WebServlet(&quot;/channel&quot;) public class ChannelServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ChannelServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub String level=request.getParameter(&quot;level&quot;); String parent=request.getParameter(&quot;parent&quot;); List channelist= new ArrayList(); if(level.equals(&quot;1&quot;)) { channelist.add(new Channel(&quot;ai&quot;,&quot;前端/区块链/人工智能&quot;)); channelist.add(new Channel(&quot;web&quot;,&quot;前端/小程序/js&quot;)); } if(level.equals(&quot;2&quot;)) { if(parent.equals(&quot;ai&quot;)) { channelist.add(new Channel(&quot;micro&quot;,&quot;微服务&quot;)); channelist.add(new Channel(&quot;blocklist&quot;,&quot;区块链&quot;)); channelist.add(new Channel(&quot;other&quot;,&quot;。。。&quot;)); } else if (parent.equals(&quot;web&quot;)) { channelist.add(new Channel(&quot;html&quot;,&quot;HTML&quot;)); channelist.add(new Channel(&quot;css&quot;,&quot;CSS&quot;)); channelist.add(new Channel(&quot;other&quot;,&quot;。。。&quot;)); } } String json=JSON.toJSONString(channelist); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().println(json); } } &lt;!--html代码:--&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){//初始化显示一级菜单 $.ajax({ &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:{&quot;level&quot;:&quot;1&quot;}, &quot;dataType&quot;:&quot;json&quot;, &quot;type&quot;:&quot;get&quot;, &quot;success&quot;:function(json) { for(var i=0;i&lt;json.length;i++) { var ch=json[i]; $(&quot;#lv1&quot;).append(&quot;&lt;option value=&apos;&quot;+ch.name +&quot;&apos;&gt;&quot;+ch.code+&quot;&lt;/option&quot;); } } }) }) $(function(){//二级菜单 $(&quot;#lv1&quot;).click(function(){ var parent=$(this).val();//返回当前的一级菜单的值 $.ajax({ &quot;url&quot;:&quot;/ajax/channel&quot;, &quot;data&quot;:{&quot;level&quot;:&quot;2&quot;,&quot;parent&quot;:parent}, &quot;dataType&quot;:&quot;json&quot;, &quot;type&quot;:&quot;get&quot;, &quot;success&quot;:function(json) { $(&quot;#lv2&gt;option&quot;).remove();//清除lv2下的所有potion下的内容 for(var i=0;i&lt;json.length;i++) { var ch=json[i]; $(&quot;#lv2&quot;).append(&quot;&lt;option value=&apos;&quot;+ch.name +&quot;&apos;&gt;&quot;+ch.code+&quot;&lt;/option&quot;); } } }) }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;select id=&quot;lv1&quot; style=&quot;width:200px;height:30px&quot;&gt; &lt;option selected=&quot;selected&quot;&gt;请选择&lt;/option&gt;//带有预先设置的下拉框 &lt;/select&gt; &lt;select id=&quot;lv2&quot; style=&quot;width:200px;height:30px&quot;&gt;&lt;/select&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>-AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX的入门学习]]></title>
    <url>%2F2019%2F09%2F06%2FAJAX%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[AJAX介绍 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 AJAX工作原理 AJAX的使用流程1.创建XMLHttpRequest对象 var xmlhttp; if(window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 var xmlhttp=new XMLHttpRequest; } else { // IE6, IE5 浏览器执行代码 var xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); }2.发送Ajax请求 xmlhttp.open(“GET”,”url”,”true); xmlhttp.send(); open(method,url,async):规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步） 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true； 同步执行：同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回这个期间客户端浏览器不能干任何事代码进入一个等待的时候，数据不返回时不会向下执行 异步执行：异步:请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕不会处于堵塞的 会一直向下执行，但是数据的返回时候触发onreadystatechange事件来完成注意：当使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可。 实际使用时 ajax推荐使用异步 实例： 服务器响应代码： import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class NewListServlet */ @WebServlet(&quot;/newslist&quot;) public class NewListServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public NewListServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub try { Thread.sleep(5000);//等待事件5000秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } List list=new ArrayList(); list.add(new News(&quot;TIOBE:2018年5月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年6月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年7月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年8月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); list.add(new News(&quot;TIOBE:2018年9月份全球编程语言排行榜&quot;,&quot;2018-5-1&quot;,&quot;TIOBE&quot;,&quot;...&quot;)); String json=JSON.toJSONString(list); System.out.println(json); response.setContentType(&quot;text/html ; charset=utf-8&quot;); response.getWriter().println(json); } }同步：var xmlhttp; if(window.XMLHttpRequest) { xmlhttp=new XMLHttpRequest(); } else { xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.open(&quot;GET&quot;,&quot;/ajax/newslist&quot;,false); xmlhttp.send(); console.log(&quot;请求发送完成&quot;); if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) { var t=xmlhttp.responseText; console.log(t); var json=JSON.parse(t); console.log(json); var html=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { var news=json[i]; html=html+&quot;&lt;h1&gt;&quot;+news.title+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;h2&gt;&quot;+news.date+&quot;&amp;nbsp;&quot;+news.source+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;hr/&gt;&quot;; } document.getElementById(&quot;container&quot;).innerHTML=html; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; xmlhttp.send();该程序会先等待当等待5000秒，5000秒后才输出请求发送完成和现显示响应内容。 异步：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var xmlhttp; if(window.XMLHttpRequest) { xmlhttp=new XMLHttpRequest(); } else { xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.open(&quot;GET&quot;,&quot;/ajax/newslist&quot;,true); xmlhttp.send(); console.log(&quot;请求发送完成&quot;); xmlhttp.onreadystatechange=function()//异步获取数据方法 { if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200) { var t=xmlhttp.responseText; console.log(t); var json=JSON.parse(t); console.log(json); var html=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { var news=json[i]; html=html+&quot;&lt;h1&gt;&quot;+news.title+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;h2&gt;&quot;+news.date+&quot;&amp;nbsp;&quot;+news.source+&quot;&lt;/h&gt;&quot; html=html+&quot;&lt;hr/&gt;&quot;; } document.getElementById(&quot;container&quot;).innerHTML=html; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;执行完会立刻发送一个“请求发送完成字样 然后过5000秒后显示响应内容3.处理服务器的响应 xmlhttp.onreadystatechange()事件用于监听AJAX的执行过程 xmlhttp.readyState属性说明XMLHttpRequest当前状态 readyState=0 请求未初始化 readyState=1 服务器连接已建立 readyState=2 请求已经被接收 readyState=3 请求正在处理 readyState=4 相应文本已经接收 xmlhttp.status属性服务器响应状态码，200：成功。400没有找到。 xmlhttp.onreadystatechange=funcition(){ if(xmlhttp.readyState==4&amp;&amp;xml.status==200){ //获取相应体的文本var responseText=xmlhttp.responseText; } } jQuery对Ajax的支持 url:发送请求地址 type:请求类型get/post datatype:服务器响应的数据类型text|json|xml|html|jsonp|script data:向如武器传递的参数 success ：接收响应时的处理函数 error ：请求失败时处理的函数 async: 要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。 实例： import java.util.List; import java.io.IOException; import java.util.ArrayList; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import com.alibaba.fastjson.JSON; /** * Servlet implementation class ZUOYE */ @WebServlet(&quot;/zuoye&quot;) public class ZUOYE extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ZUOYE() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub response.setContentType(&quot;text/html ; charset=utf-8&quot;); String tt=request.getParameter(&quot;t&quot;); List list=new ArrayList(); list.add(&quot;稻香&quot;); list.add(&quot;晴天&quot;); list.add(&quot;告白气球 &quot;); List list2=new ArrayList(); list2.add(&quot;千千阕歌&quot;); list2.add(&quot;傻女&quot;); list2.add(&quot;七友 &quot;); List list3=new ArrayList(); list3.add(&quot;一块红布&quot;); list3.add(&quot;假行僧&quot;); list3.add(&quot;新长征路上的摇滚 &quot;); int m=Integer.parseInt(tt); if(m==1) { String json=JSON.toJSONString(list); response.getWriter().println(json); } else if(m==2) { String json2=JSON.toJSONString(list2); response.getWriter().println(json2); } if(m==3) { String json3=JSON.toJSONString(list3); response.getWriter().println(json3); } } } ajax代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; input { width:33%; text-align:center; font-weight:bold;} div { margin-left:50%; width:100px; margin-top:200px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;b1&quot; value=&quot;流行歌曲&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;b2&quot; value=&quot;经典歌曲&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;b3&quot; value=&quot;摇滚歌曲&quot;&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.js&quot;&gt; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;input[id=&apos;b1&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=1&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json) { console.log(json); var s=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); $(&quot;input[id=&apos;b2&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=2&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)//已经变成了json无需进行字符串的转化 { var s=&quot;&quot;; console.log(json); for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); $(&quot;input[id=&apos;b3&apos;]&quot;).click(function(){ $.ajax({ &quot;url&quot;:&quot;/ajax/zuoye&quot;, &quot;type&quot;:&quot;get&quot;, &quot;data&quot;:&quot;t=3&quot;, &quot;dataType&quot;:&quot;json&quot;, &quot;success&quot;:function(json)//已经变成了json无需进行字符串的转化 { console.log(json); var s=&quot;&quot;; for(var i=0;i&lt;json.length;i++) { s=s+&quot;&lt;h2&gt;&quot;+json[i]+&quot;&lt;/h&gt;&quot;; } $(&quot;#div1&quot;).html(s); } }) }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;结果：]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的入门学习]]></title>
    <url>%2F2019%2F09%2F05%2FJQuery%E7%9A%84%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1jQuery的介绍与下载安装1.1什么是jQuery jQuery是一个快速、简洁的JavaScript框架，它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 jQuery的核心特性可以总结为:具有独特的链式语法和短小清晰的多功能接口;具有高效灵活的css选择器，并且可对CSS选择器进行扩展;拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等。 1.2 jQuery 下载 jQuery官网下载最新版本jquery-3.4.1.js将下载好的jQuery放在WebContent里面 jQuery采用独立的JS文件发布 IDE:Eclipse，Hbuilder，sublime，webstorm 2.jQuery基础语法 jQuery 选择器允许对 HTML 元素组或单个元素进行操作。jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”(或选择)HTML 元素。 它基于已经存在的CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头:$()。 $(selector).action() ###2.2文档就绪事件 入口函数$(document).ready(function(){ // 开始写 jQuery 代码... });简写： $(function(){ // 开始写 jQuery 代码... });这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。如果在文档没有完全加载之前就运行函数，操作可能失败。 jQuery 入口函数与 JavaScript 入口函数的区别： jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行 2.3基本选择器(括号里面要用上引号)1.$(“#id”)–ID选择器，指定Id元素对象 2.$(“标签”)–元素选择器，选择指定标签名的选择器 3.$(“.class”)–类选择器，选中拥有指定css类的元素 4.$(“S1,S2,S3”)组合选择器，对元素进行组合 实例： &lt;script&gt; $(document).ready(function(){ $(&quot;p&quot;).click(function(){ $(this).hide(); }); }); &lt;/script&gt; &lt;body&gt; &lt;p&gt;如果你点我，我就会消失。&lt;/p&gt; &lt;/body&gt;2.4层叠选择器$(“ancestor descendant”) 后代选择器 $(“ancestor&gt;descendant”)子选择器 $(“prev ~ siblings”)兄弟选择器 后代选择器与子选择器最大的区别就是后代选择器可以选择该节点之后的所有节点 而子选择器只能选择该节点的一个子节点。兄弟选择器是选择节点之后所有符合要求的平级节点** 2.5属性选择器$(“selector[attribute=value]”)选中属性值等于具体值的组件 $(“selector[attribute^=value]”)选中属性值以某值开头的组件 $(“selector[attribute$=value]”)选中属性值以某值结尾的组件 $(“selector[attribute * =value]”)选中属性值包含某值的组件 ####2.6位置选择器 $(“selector:first”)获取第一个元素 $(“selector:last”)获取最后一个元素 $(“selector:even”)获取偶数的元素（从0开始） $(“selector:odd”)获取奇数位置的元素（从0开始） $(“selector:eq(n)”)获取指定位置的元素（从0开始） 2.7表单选择器$(“selector:input”)所有的输入元素 $(“selector:text”)所有的文本框 $(“selector:password”)获取密码框 $(“selector:submit”)获取提交按钮 $(“selector:reset) 获取重置按钮 3.操作元素的属性 attr(name|properties|key) 获取或者设置元素属性 removeAttr(name) 移除元素属性 如果attr() 括号中有一个元素就是获取属性如果有两个就是更改属性 var href_attr=$(&quot;a[href*=&apos;163&apos;]&quot;).attr(&quot;href&quot;);//获取元素 alert(href_attr); $(&quot;a[href*=&apos;163&apos;]&quot;).attr(&quot;href&quot;,&quot;http://www.163.com&quot;);//更改元素 $(&quot;a&quot;).removeAttr(&quot;href&quot;);//移除属性，此时a标签不再有超链接属性4.操作元素的CSS属性 css()获取设置匹配元素样式属性 addClass() 为每个匹配的元素添加指定的类名 removeClass() 为所有匹配的元素中删除全部或者指定的类 $(&quot;a&quot;).css(&quot;color&quot;,&quot;red&quot;);//设置a标签中的文字是红色 var color=$(&quot;a&quot;).css(&quot;color&quot;);//获取a标签的颜色 alert(color); $(&quot;a&quot;).css({&quot;color&quot;:&quot;red&quot;,&quot;font-weight&quot;:&quot;bold&quot;,&quot;font-size&quot;:&quot;italic&quot;});//多个属性的设置 可以使用json表达式 $(&quot;li&quot;).addClass(&quot;highlight myclass&quot;);//添加类 $(&quot;p&quot;).removeClass(&quot;myclass&quot;);//移除类 5.设置元素内容和添加元素以及删除元素5.1设置元素内容 val() 获取或者设置输入项的值 text()获取或设置元素的纯文本 html() 获取或设置元素内容的HTM $(&quot;input[name=&apos;uname&apos;]&quot;).val(&quot;administrator&quot;);//设置 var s=$(&quot;input[name=&apos;uname&apos;]&quot;).val();//获取text与html中 最大的区别是对文本中的html标签是否进行转义text不进行转义而html进行转义 一般用text方法对纯文本进行设置和获取 5.2添加新的HTML内容 append() - 在被选元素的结尾插入内容 $(“p”).append(“追加文本”); prepend() - 在被选元素的开头插入内容 $(“p”).prepend(“在开头追加文本”); after() - 在被选元素之后插入内容 $(“img”).after(“在后面添加文本”); before() - 在被选元素之前插入内容 $(“img”).before(“在前面添加文本”); 5.3删除元素 remove() - 删除被选元素（及其子元素） $(“#div1”).remove(); empty() - 从被选元素中删除子元素 $(“#div1”).empty(); 6.jQuery事件处理方法jQuery 事件方法语法在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。 页面中指定一个点击事件： $(&quot;p&quot;).click();下一步是定义什么时间触发事件。可以通过一个事件函数实现： $(&quot;p&quot;).click(function(){ // 动作触发后执行的代码!! }); click()click() 方法是当按钮点击事件被触发时会调用一个函数。该函数在用户点击 HTML 元素时执行。 dblclick()当双击元素时，会发生 dblclick 事件。 mouseenter()当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseleave()当鼠标指针离开元素时，会发生 mouseleave 事件。mouseleave() 方法触发 mouseleave 事件， mousedown()当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。mousedown()方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数 mouseup()当在元素上松开鼠标按钮时，会发生 mouseup 事件。mouseup() 方法触发 mouseup 事件，或规定当发生 mouseup 事件时运行的函数： hover()hover()方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 focus()当元素获得焦点时，发生 focus 事件。当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数. blur()当元素失去焦点时，发生 blur 事件。blur() 方法触发 blur 事件，或规定当发生 blur 事件时运行的函数： $(&quot;p.myclass&quot;).click(function(){ $(this).css(&quot;background-color&quot;,&quot;green&quot;);//此时myclass的背景色变为绿色 });7.jQuery效果- 隐藏和显示jQuery hide() 和 show() 通过 jQuery，可以使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： $(&quot;#hide&quot;).click(function(){ $(&quot;p&quot;).hide(); }); $(&quot;#show&quot;).click(function(){ $(&quot;p&quot;).show(); });]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON入门学习]]></title>
    <url>%2F2019%2F08%2F31%2FJSON%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.什么是JSON 是一种轻量级的数据交换格式。他基于 javascript 语法的子集，即数组和对象表示。 采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率. 客户端向服务器端发送请求后，服务器端怎么才能把用户需要的数据返回给客户端呢。这时我们就需要用一个指定的格式将数据，按照指定格式返回客户端。这时就有了两种数据传输的方式（XML和Json),在普通的Web应用中，不管是服务器端还是客户端解析XML代码会非常麻烦，所以这时Json就更加满足数据传输解析的要求。采用Json格式的方式进行数据的传输，不仅方便传输解析，还特别易于人阅读和编写 2.JSON的语法规则 数据由键(key),值(value)描述,由逗号分隔 大括号代表一个完整的对象,又有多个键/值对 中括号保存数组,多个对象之间使用逗号分割 注意:key和value如果是字符串的时候一定要有引号 3.JSON实例利用JSON存储员工信息JSON: [ { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;李宁&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot; }, { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;张三&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot;, &quot;customers&quot;: [ { &quot;cname&quot;: &quot;李东&quot; }, { &quot;canme&quot;: &quot;王五&quot; } ] } ]4.可以用JSON来代替xml1、JSON的解释性能要比XML要好，要简洁紧凑。2、可读性要比XML好。JSON本身就是JavaScript的语法，和程序员的思维，而非文档编写的思维。3、JavaScript原生支持，客户端浏览器不需要为此使用额外的解释器，在web环境中使用特别合适。 xml&lt;student&gt; &lt;name&gt;xiaoming&lt;/name&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;age&gt;26&lt;/age&gt; &lt;/student&gt; 替代后[{&quot;name&quot;:&quot;xiaoming&quot;,&quot;sex&quot;:&quot;female&quot;,&quot;age&quot;:&quot;26&quot;}]5. javascript访问JSON对象1.&lt;body&gt; &lt;h2&gt;在 JavaScript 中创建 JSON 对象&lt;/h2&gt; &lt;p&gt; Name: &lt;span id=&quot;jname&quot;&gt;&lt;/span&gt;&lt;br/&gt; Age: &lt;span id=&quot;jage&quot;&gt;&lt;/span&gt;&lt;br/&gt; Address: &lt;span id=&quot;jstreet&quot;&gt;&lt;/span&gt;&lt;br/&gt; Phone: &lt;span id=&quot;jphone&quot;&gt;&lt;/span&gt;&lt;br/&gt; &lt;/p&gt; &lt;script type=&quot;text/javascript&quot;&gt; var JSONObject= { &quot;name&quot;:&quot;Bill Gates&quot;, &quot;street&quot;:&quot;Fifth Avenue New York 666&quot;, &quot;age&quot;:56, &quot;phone&quot;:&quot;555 1234567&quot;}; document.getElementById(&quot;jname&quot;).innerHTML=JSONObject.name document.getElementById(&quot;jage&quot;).innerHTML=JSONObject.age document.getElementById(&quot;jstreet&quot;).innerHTML=JSONObject.street document.getElementById(&quot;jphone&quot;).innerHTML=JSONObject.phone &lt;/script&gt; &lt;/body&gt;2.&lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; json是一个数组里面有各个对象的信息 var json= [ { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;李宁&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot; }, { &quot;empno&quot;: 73652, &quot;ename&quot;: &quot;张三&quot;, &quot;job&quot;: &quot;软件工程师&quot;, &quot;hiredate&quot;: &quot;2017-50-02&quot;, &quot;salary&quot;: 13000, &quot;dname&quot;: &quot;研发部&quot;, &quot;customers&quot;: [ { &quot;cname&quot;: &quot;李东&quot; }, { &quot;cname&quot;: &quot;王五&quot; } ] } ]; for(var i=0;i&lt;json.length;i++) { var emp=json[i]; document.write(&quot;&lt;h1&gt;&quot;); document.write(emp.empno); document.write(&quot;,&quot;+emp.ename); document.write(&quot;,&quot;+emp.job); document.write(&quot;,&quot;+emp.hiredate); document.write(&quot;,&quot;+emp.salary); document.write(&quot;,&quot;+emp.dname); document.write(&quot;&lt;/h1&gt;&quot;); //访问嵌套的地方 if(emp.customers!=null){ document.write(&quot;&lt;h2&gt;---&quot;); for(var j=0;i&lt;emp.customers.length;j++) { var customer=emp.customers[j]; document.write(customer.cname); } document.write(&quot;&lt;/h2&gt;---&quot;); } } &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;6 JSON与字符串的互相转换字符串转json：JSON.parse(字符串名)； json转字符串:JSON.stringify(JSON名) ####6.1实例: string-&gt;json &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;字符串与JSON互相转换&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var str=&quot;{\&quot;class_name\&quot;:\&quot;五年级三班\&quot;}&quot;;//字符串 var json=JSON.parse(str); console.log(str); console.log(json); &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;json-&gt;string &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;字符串与JSON互相转换&lt;/title&gt; var json1={&quot;clssname&quot;:&quot;五年级四班&quot;}; var str1=JSON.stringify(json1); console.log(json1); console.log(str1); &lt;/script&gt; &lt;/head&gt; &lt;/body&gt; &lt;/html&gt;json初始化可以看做成创建一个对象 var json2={}; json2.class_name=”五年级5班”; json2.foor=”四层”; json2.teacher=”王一凡”; console.log(json2); ###7. JSON与java的交互 java的JSON工具包还有FastJson,Jackson.Gson,Json-lib.. FastJson是阿里巴巴著名的JSON 序列化与反序列工具包 FastJson国内拥有大量的使用者,拥有Api简单,效率高等优点 ####7.1FastJSON的下载和安装:去github官网官网搜索fastjson :-&gt; alibaba/fastjson,-&gt;Documentation下Documentation Home在下载和使用栏下下载最新版jar包 下载后将其拖进eclipse工程下的WEB-INF下的lib文件夹中就可以使用了 7.2FastJson对象序列化与反序列化和JSON注解 什么是序列化？ 序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。 为什么要序列化对象 把对象转换为字节序列的过程称为对象的序列化把字节序列恢复为对象的过程称为对象的反序列化 1.类转换成字符串：String json= JSON.toJSONString(employee); 2.字符串转换成类:Employee emp=JSON.parseObject(json,Employee.class);//转到Employee.class 类 7.3 JSON的注释：JSON注释对下一行代码生效@JSONField(format=”yyyy-MM-dd “)设置日期格式@JSONField(serialize=false)//不将其进行序列化,它注释的地方下一条信息不显示 Employee类: package com.json; import java.util.Date; import com.alibaba.fastjson.annotation.JSONField; public class Employee { private Integer empno; private String name; private String job; @JSONField(format=&quot;yyyy-MM-dd &quot;) private Date hdate; private Float salary; @JSONField(serialize=false)//不对dname进行序列化 private String dname; public Integer getEmpno() { return empno; } public void setEmpno(Integer empno) { this.empno = empno; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getJob() { return job; } public void setJob(String job) { this.job = job; } public Date getHdate() { return hdate; } public void setHdate(Date hdate) { this.hdate = hdate; } public Float getSalary() { return salary; } public void setSalary(Float salary) { this.salary = salary; } public String getDname() { return dname; } public void setDname(String dname) { this.dname = dname; } } import java.util.Calendar; import com.alibaba.fastjson.JSON; public class FastJson { public static void main(String[] args) { Employee employee= new Employee(); employee.setEmpno(4488); employee.setName(&quot;晓东&quot;); employee.setJob(&quot;客户经理&quot;); employee.setSalary(10000f); employee.setDname(&quot;市场部&quot;); Calendar c=Calendar.getInstance(); c.set(2019,0,30,0,0,0); employee.setHdate(c.getTime()); //FastJson中提供了JSON对象。完成对象与JSON字符串的相互转换 String json= JSON.toJSONString(employee); System.out.println(json); Employee emp=JSON.parseObject(json,Employee.class); System.out.println(emp.getName()); } } 7.4 FastJSON对象数组序列化和反序列化实例:对象数组转为字符串:String json=JSON.toJSONString(emplist); 字符串再转回对象数组:List emps=JSON.parseArray(json,Employee.class); import java.util.ArrayList; import java.util.List; import com.alibaba.fastjson.JSON; public class FastJson2 { public static void main(String[] args) { List emplist= new ArrayList(); for(int i=0;i&lt;100;i++) { Employee employee=new Employee(); employee.setEmpno(4488+i); employee.setName(&quot;员工&quot;+i); emplist.add(employee); } String json=JSON.toJSONString(emplist); System.out.println(json); List&lt;Employee&gt; emps=JSON.parseArray(json,Employee.class); for(Employee e:emps) { System.out.println(e.getEmpno()+&quot;:&quot;+e.getName()); } } }]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nexT的配置优化]]></title>
    <url>%2F2019%2F08%2F27%2FnexT%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[写在前面这是我的第一篇博客，我这个博客用的是用的比较广泛的nexT主题，所以想记录一下我对nexT简单基础配置 hexo最常用的命令 hexo s:启动本地服务器，用于预览主题,预览的同时可以修改文章内容或主题代码，保存后刷新页面即可,对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果hexo g:生成网站静态文件到默认设置的 public 文件夹。便于查看网站生成的静态文件或者手动部署网站； hexo d:自动生成网站静态文件，并部署到设定的仓库。hexo clean:清除缓存文件 db.json 和已生成的静态文件 public 。 ####### 每次修改后都要在博客所在文件夹右键 Git bush Here输入 hexo s 预览效果，如果效果合适，再输入hexo g hexo d 发布到设定的github仓库如果失败可以尝试 hexo clean 再进行重复操作 nexT配置优化1 启用主题打开所在博客所在文件夹的站点配置文件_config.yml,找到字段theme将theme后面改成，next（注意下载的next主题的文件名一定也是next否则theme后面写next不生效） 2 将next主题的文字改成中文我们进入博客所在文件夹-&gt;themes-&gt;next-&gt;lauguages我们可以发现这里面有好多YML文件，官方文档给的是中文改成zh-Hans.但是我当时改完之后发现好像变成了德语，后来查阅这个laguages文件才发现，简体中文对应的是zh-CN明确语言之后我们再次进入站点配置文件_config.yml 找到laguages字段 冒号后面写zh-CN 3 增加标签页和分类页 进入next里找到主题的配置文件，找到关键字menu 在menu下tags和categories前面的# 去掉]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>nexT</tag>
      </tags>
  </entry>
</search>
